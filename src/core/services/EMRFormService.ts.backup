// Legacy service with intentional type bypasses - refactor planned
import { z } from 'zod';
import supabase from '@/core/auth/supabaseClient';
import { formDataSourceSupabase } from '../dataSources/formDataSourceSupabase';
import { AuditLogger } from '../audit/AuditLogger';
import { trackMetric } from '../services/UsageAnalyticsService';
import { FormDataSource } from '../dataSources/FormDataSource';
import { EMRContent, EMRForm } from '@/types/forms';
import { SuggestionType } from '@/types/agent';
import { StructuredErrorFactory, ErrorLogger } from '@/types/errors';

/**
 * Tipos de secciones del EMR donde se pueden integrar sugerencias
 */
export type EMRSection = 'subjective' | 'objective' | 'assessment' | 'plan' | 'notes';

/**
 * Tipos de sugerencias que se pueden integrar al EMR
 */
export const INTEGRABLE_SUGGESTION_TYPES = ['recommendation', 'warning', 'info'] as const;
export type IntegrableSuggestionType = typeof INTEGRABLE_SUGGESTION_TYPES[number];

/**
 * Esquema de validación para el formulario estructurado del EMR
 */
export const EMRFormSchema = z.object({
  id: z.string().optional(),
  visitId: z.string(),
  patientId: z.string(),
  professionalId: z.string(),
  subjective: z.string().default(''),
  objective: z.string().default(''),
  assessment: z.string().default(''),
  plan: z.string().default(''),
  notes: z.string().default(''),
  updatedAt: z.string().optional(),
  createdAt: z.string().optional()
});

/**
 * Interfaz para representar una sugerencia que se integrará al EMR
 */
export interface SuggestionToIntegrate {
  id: string;
  content: string;
  type: IntegrableSuggestionType;
  sourceBlockId: string;
  field?: string;
}

/**
 * Servicio para gestionar la integración de sugerencias al EMR estructurado
 */
export class EMRFormService {
  private formDataSource: FormDataSource;

  constructor(formDataSource: FormDataSource) {
    this.formDataSource = formDataSource;
  }

  /**
   * Genera un EMR fallback cuando las operaciones de base de datos fallan
   */
  private static generateFallbackEMRForm(visitId: string, patientId: string): EMRForm {
    const timestamp = new Date().toISOString();
    return {
      id: `fallback-emr-${Date.now()}`,
      visitId,
      patientId,
      professionalId: 'unknown-professional',
      subjective: '⚠️ Formulario generado por sistema de respaldo - Requiere revisión médica',
      objective: '',
      assessment: '',
      plan: '',
      notes: `📝 NOTA TÉCNICA: Formulario creado automáticamente por falla del sistema el ${timestamp}. Todos los datos requieren validación médica.`,
      updatedAt: timestamp,
      createdAt: timestamp
    };
  }

  /**
   * Obtiene el formulario EMR para una visita específica
   * @param visitId ID de la visita
   * @returns Formulario EMR o null si no existe
   */
  public static async getEMRForm(visitId: string): Promise<EMRForm | null> {
    
    try {
      // Timeout para operaciones de base de datos
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Database timeout')), 15000)
      );

      const dbOperation = async () => {
        // Obtener el formulario clínico desde Supabase
        const forms = await formDataSourceSupabase.getFormsByVisitId(visitId);
        
        // Buscar un formulario de tipo SOAP (o el primero que exista)
        const soapForm = forms.find(form => form.form_type === 'SOAP') || forms[0];
        
        if (!soapForm) return null;
        
        // Convertir al formato EMRForm
        let emrContent: EMRContent;
        
        try {
          // Intentar parsear el contenido JSON
          emrContent = JSON.parse(soapForm.content);
        } catch (parseError) {
          const structuredError = 
      StructuredErrorFactory.createDatabaseError(
            parseError as Error,
            'EMR content parse',
            undefined,
            visitId
          );
          
          ErrorLogger.logStructuredError(structuredError);
          return null;
        }
        
        // Construir y validar el objeto EMRForm
        const emrForm: EMRForm = {
          id: soapForm.id,
          visitId: soapForm.visit_id,
          patientId: soapForm.patient_id,
          professionalId: soapForm.professional_id,
          subjective: emrContent.subjective || '',
          objective: emrContent.objective || '',
          assessment: emrContent.assessment || '',
          plan: emrContent.plan || '',
          notes: emrContent.notes || '',
          updatedAt: soapForm.updated_at,
          createdAt: soapForm.created_at
        };
        
        // Validar con Zod
        try {
          return EMRFormSchema.parse(emrForm);
        } catch (validationError) {
          const structuredError = 
      StructuredErrorFactory.createValidationError(
            'EMR_FORM_VALIDATION_FAILED',
            'EMR form data validation failed',
            { visitId, formData: emrForm },
            validationError as Error,
            'use_fallback_data'
          );
          
          ErrorLogger.logStructuredError(structuredError);
          return null;
        }
      };

      return await Promise.race([dbOperation(), timeoutPromise]) as EMRForm | null;
      
    } catch (error) {
      const structuredError = 
      StructuredErrorFactory.createDatabaseError(
        'EMR_FORM_FETCH_FAILED',
        'Failed to fetch EMR form from database',
        { visitId },
        error as Error,
        'use_fallback_data'
      );
      
      ErrorLogger.logStructuredError(structuredError);
      throw structuredError; // Re-lanzar para que el caller maneje el fallback
    }
  }

  /**
   * Determina la sección del EMR donde debe insertarse una sugerencia según su tipo
   * @param suggestionType Tipo de sugerencia
   * @returns Sección del EMR correspondiente
   */
  public static mapSuggestionTypeToEMRSection(
    suggestionType: SuggestionType
  ): EMRSection {
    switch (suggestionType) {
      case 'recommendation':
        return 'plan';
      case 'warning':
        return 'assessment';
      case 'info':
        return 'notes';
      case 'diagnostic':
        return 'assessment';
      case 'treatment':
        return 'plan';
      case 'followup':
        return 'plan';
      case 'contextual':
        return 'notes';
      default:
        return 'notes';
    }
  }

  /**
   * Verifica si una sugerencia ya ha sido integrada anteriormente
   * @param emrForm Formulario EMR
   * @param suggestion Sugerencia a verificar
   * @returns true si ya existe, false en caso contrario
   */
  private static suggestionAlreadyIntegrated(
    emrForm: EMRForm,
    suggestion: SuggestionToIntegrate
  ): boolean {
    const section = this.mapSuggestionTypeToEMRSection(suggestion.type);
    const prefixedContent = `🔎 ${suggestion.content}`;
    
    return emrForm[section].includes(prefixedContent);
  }

  /**
   * Inserta una sugerencia en el EMR estructurado
   * @param suggestion Sugerencia a insertar
   * @param visitId ID de la visita
   * @param patientId ID del paciente
   * @param userId ID del usuario que realiza la acción
   * @returns true si se insertó correctamente, false en caso contrario
   */
  public static async insertSuggestion(
    suggestion: SuggestionToIntegrate,
    visitId: string,
    patientId: string,
    userId: string = 'anonymous'
  ): Promise<boolean> {
    
    
    try {
      // Verificar que el tipo de sugerencia sea integrable
      if (!INTEGRABLE_SUGGESTION_TYPES.includes(suggestion.type)) {
        const structuredError = 
      StructuredErrorFactory.createValidationError(
          'UNSUPPORTED_SUGGESTION_TYPE',
          'Suggestion type not supported for integration',
          { suggestionType: suggestion.type, supportedTypes: INTEGRABLE_SUGGESTION_TYPES },
          new Error(`Unsupported suggestion type: ${suggestion.type}`),
          'skip_operation'
        );
        
        ErrorLogger.logStructuredError(structuredError);
        return false;
      }

      // Obtener o crear el formulario EMR para esta visita
      let emrForm: EMRForm | null = null;
      let usingFallback = false;
      
      try {
        emrForm = await this.getEMRForm(visitId);
      } catch (error) {
        // Si falla la obtención, usar formulario fallback
        emrForm = this.generateFallbackEMRForm(visitId, patientId);
        usingFallback = true;
        
        const structuredError = 
      StructuredErrorFactory.createDatabaseError(
          'EMR_FORM_FETCH_FALLBACK',
          'Using fallback EMR form due to database error',
          { visitId, patientId, usingFallback: true },
          error as Error,
          'continue_with_fallback'
        );
        
        ErrorLogger.logStructuredError(structuredError);
      }
      
      if (!emrForm) {
        // Si no hay formulario, intentar obtener professionalId para crear uno nuevo
        try {
          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Database timeout')), 10000)
          );

          const dbQuery = supabase
            .from('visits')
            .select('professional_id')
            .eq('id', visitId)
            .single();

          const { data, error } = await Promise.race([dbQuery, timeoutPromise]) as { data: { professional_id: string } | null; error: Error | null };
          
          if (error || !data) {
            throw new Error(`Failed to fetch professional_id: ${error?.message || 'Unknown error'}`);
          }
          
          const professionalId = data.professional_id;
          
          // Crear un nuevo formulario EMR
          emrForm = {
            visitId,
            patientId,
            professionalId,
            subjective: '',
            objective: '',
            assessment: '',
            plan: '',
            notes: '',
            updatedAt: new Date().toISOString(),
            createdAt: new Date().toISOString()
          };
          
        } catch (error) {
          // Usar fallback si falla la creación de formulario nuevo
          emrForm = this.generateFallbackEMRForm(visitId, patientId);
          usingFallback = true;
          
          const structuredError = 
      StructuredErrorFactory.createDatabaseError(
            'PROFESSIONAL_ID_FETCH_FAILED',
            'Failed to fetch professional ID, using fallback form',
            { visitId, patientId },
            error as Error,
            'continue_with_fallback'
          );
          
          ErrorLogger.logStructuredError(structuredError);
        }
      }

      // Verificar si la sugerencia ya ha sido integrada
      if (this.suggestionAlreadyIntegrated(emrForm, suggestion)) {
        return false; // No integrar sugerencias duplicadas
      }

      // Determinar la sección donde insertar la sugerencia
      const section = this.mapSuggestionTypeToEMRSection(suggestion.type);
      
      // Prefijo visual para indicar que es una sugerencia integrada
      const prefixedContent = usingFallback 
        ? `🔎💾 ${suggestion.content} [MODO SEGURO]`
        : `🔎 ${suggestion.content}`;
      
      // Concatenar la sugerencia al contenido existente
      emrForm[section] = emrForm[section]
        ? `${emrForm[section]}\n\n${prefixedContent}`
        : prefixedContent;

      // Intentar actualizar el formulario en la base de datos
      try {
        const timeoutPromise = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Database timeout')), 10000)
        );

        const updateOperation = supabase
          .from('forms')
          .update({
            content: JSON.stringify({
              subjective: emrForm.subjective,
              objective: emrForm.objective,
              assessment: emrForm.assessment,
              plan: emrForm.plan,
              notes: emrForm.notes
            }),
            updated_at: new Date().toISOString()
          })
          .eq('id', emrForm.id);

        const { error } = await Promise.race([updateOperation, timeoutPromise]) as { error: Error | null };

        if (error) {
          throw error;
        }

      } catch (updateError) {
        const structuredError = 
      StructuredErrorFactory.createDatabaseError(
          'EMR_FORM_UPDATE_FAILED',
          'Failed to update EMR form in database',
          { 
            suggestionId: suggestion.id, 
            visitId, 
            section,
            usingFallback 
          },
          updateError as Error,
          usingFallback ? 'data_stored_locally' : 'retry_later'
        );
        
        ErrorLogger.logStructuredError(structuredError);
        
        if (!usingFallback) {
          return false; // Fallar si no estamos en modo fallback
        }
        // En modo fallback, continuamos aunque falle la actualización
      }

      // Intentar registrar el evento de auditoría (no crítico)
      try {
        await AuditLogger.logEvent(
          'suggestion.integrated',
          userId,
          {
            suggestionId: suggestion.id,
            suggestionType: suggestion.type,
            section,
            content: suggestion.content,
            usingFallback
          },
          visitId
        );
      } catch (auditError) {
        // Log del error de auditoría pero no fallar la operación
        const structuredError = 
      StructuredErrorFactory.createSystemError(
          auditError as Error,
          'suggestion audit logging',
          userId,
          visitId
        );
        
        ErrorLogger.logStructuredError(structuredError);
      }

      // Intentar registrar métrica de uso (no crítico)
      try {
        trackMetric(
          'suggestion_integrated',
          userId,
          visitId,
          1,
          {
            suggestionType: suggestion.type,
            section,
            usingFallback
          }
        );
      } catch (metricsError) {
        // Log del error de métricas pero no fallar la operación
        const structuredError = 
      StructuredErrorFactory.createSystemError(
          metricsError as Error,
          'suggestion metrics tracking',
          userId,
          visitId
        );
        
        ErrorLogger.logStructuredError(structuredError);
      }

      return true;
      
    } catch (error) {
      const structuredError = 
      StructuredErrorFactory.createSystemError(
        error as Error,
        'suggestion integration',
        userId,
        visitId
      );
      
      ErrorLogger.logStructuredError(structuredError);
      return false;
    }
  }

  /**
   * Obtiene el contenido de una sección específica del EMR
   * @param visitId ID de la visita
   * @param section Sección del EMR a obtener
   * @returns Contenido de la sección o cadena vacía si no existe
   */
  public static async getSectionContent(
    visitId: string,
    section: EMRSection
  ): Promise<string> {
    
    
    try {
      const emrForm = await this.getEMRForm(visitId);
      return emrForm ? emrForm[section] : '';
    } catch (error) {
      const structuredError = 
      StructuredErrorFactory.createDatabaseError(
        error as Error,
        'EMR section fetch',
        undefined,
        visitId
      );
      
      ErrorLogger.logStructuredError(structuredError);
      return '⚠️ Error al cargar contenido - Requiere recarga manual';
    }
  }

  /**
   * Actualiza el formulario EMR con nuevos datos
   * @param formData Datos del formulario a actualizar
   * @param userId ID del usuario que realiza la actualización
   * @returns true si se actualizó correctamente, false en caso contrario
   */
  public static async updateEMRForm(
    formData: EMRForm,
    userId: string
  ): Promise<boolean> {
    
    
    try {
      // Validar los datos del formulario
      let validatedData: EMRForm;
      
      try {
        validatedData = EMRFormSchema.parse(formData);
      } catch (validationError) {
        const structuredError = 
      StructuredErrorFactory.createValidationError(
          'EMR form',
          formData,
          'valid EMR form structure',
          userId
        );
        
        ErrorLogger.logStructuredError(structuredError);
        return false;
      }

      // Actualizar el formulario en la base de datos
      try {
        const timeoutPromise = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Database timeout')), 15000)
        );

        const updateOperation = supabase
          .from('forms')
          .update({
            content: JSON.stringify({
              subjective: validatedData.subjective,
              objective: validatedData.objective,
              assessment: validatedData.assessment,
              plan: validatedData.plan,
              notes: validatedData.notes
            }),
            updated_at: new Date().toISOString()
          })
          .eq('id', validatedData.id);

        const { error } = await Promise.race([updateOperation, timeoutPromise]) as { error: Error | null };

        if (error) {
          throw error;
        }

      } catch (updateError) {
        const structuredError = 
      StructuredErrorFactory.createDatabaseError(
          updateError as Error,
          'EMR form database update',
          userId,
          validatedData.visitId
        );
        
        ErrorLogger.logStructuredError(structuredError);
        return false;
      }

      // Intentar registrar el evento de auditoría (no crítico)
      try {
        await AuditLogger.logEvent(
          'form.updated',
          userId,
          {
            formId: validatedData.id,
            visitId: validatedData.visitId,
            patientId: validatedData.patientId
          },
          validatedData.visitId
        );
      } catch (auditError) {
        // Log del error de auditoría pero no fallar la operación
        const structuredError = 
      StructuredErrorFactory.createSystemError(
          'EMR_UPDATE_AUDIT_FAILED',
          'Failed to log EMR form update audit event',
          { formId: validatedData.id, visitId: validatedData.visitId },
          auditError as Error,
          'continue_without_audit'
        );
        
        ErrorLogger.logStructuredError(structuredError);
      }

      return true;
      
    } catch (error) {
      const structuredError = 
      StructuredErrorFactory.createSystemError(
        'EMR_FORM_UPDATE_CRITICAL_FAILED',
        'Critical error during EMR form update',
        { formId: formData.id, visitId: formData.visitId },
        error as Error,
        'contact_support'
      );
      
      ErrorLogger.logStructuredError(structuredError);
      return false;
    }
  }
} 