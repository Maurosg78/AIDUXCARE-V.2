/**
 * ðŸ§  ADVANCED SOAP CLASSIFIER - Clasificador SOAP Avanzado
 * 
 * Basado en recomendaciones de ChatGPT para mejorar la clasificaciÃ³n
 * automÃ¡tica de conversaciones mÃ©dicas en secciones S.O.A.P.
 * 
 * Optimizado especÃ­ficamente para fisioterapia/rehabilitaciÃ³n
 * 
 * @author AiDuxCare Team + ChatGPT Optimization
 * @date Junio 2025
 * @version 3.0
 */

// === INTERFACES ===

export interface ClassificationResult {
  section: 'S' | 'O' | 'A' | 'P';
  confidence: number;
  reasoning: string;
  entities: MedicalEntities;
}

export interface MedicalEntities {
  anatomia: string[];
  sintomas: string[];
  procedimientos: string[];
  medicamentos: string[];
}

export interface SOAPSegment {
  id: string;
  text: string;
  speaker: 'PATIENT' | 'THERAPIST' | 'UNKNOWN';
  classification: ClassificationResult;
  timestamp: number;
}

export interface CompletedSOAP {
  subjective: SOAPSegment[];
  objective: SOAPSegment[];
  assessment: string;
  plan: SOAPSegment[];
  summary: {
    totalSegments: number;
    confidence: number;
    keyFindings: string[];
    autoGeneratedAssessment: boolean;
  };
}

// === CLASIFICADOR PRINCIPAL ===

export class AdvancedSOAPClassifier {
  
  // === 1. ALGORITMO NLP MEJORADO PARA CLASIFICACIÃ“N SOAP ===
  
  public classifySOAPSegment(text: string, speaker: 'PATIENT' | 'THERAPIST' | 'UNKNOWN'): ClassificationResult {
    const lower = text.toLowerCase().trim();
    
    // Extraer entidades mÃ©dicas primero
    const entities = this.extractMedicalEntities(text);
    
    // ClasificaciÃ³n por hablante con patrones especÃ­ficos
    if (speaker === 'PATIENT') {
      return this.classifyPatientStatement(lower, entities);
    } else if (speaker === 'THERAPIST') {
      return this.classifyTherapistStatement(lower, entities);
    } else {
      // Inferir hablante y clasificar
      const inferredSpeaker = this.guessSpeaker(text);
      return this.classifySOAPSegment(text, inferredSpeaker);
    }
  }

  // === CLASIFICACIÃ“N ESPECÃFICA PARA PACIENTE ===
  
  private classifyPatientStatement(text: string, entities: MedicalEntities): ClassificationResult {
    
    // SÃNTOMAS Y SENSACIONES â†’ S (Alta confianza)
    if (this.matchesPatterns(text, this.medicalPatterns.sintomasSubjetivos)) {
      return {
        section: 'S',
        confidence: 0.95,
        reasoning: 'SÃ­ntomas subjetivos reportados por paciente',
        entities
      };
    }
    
    // INFORMACIÃ“N FUNCIONAL â†’ S
    if (this.matchesPatterns(text, this.medicalPatterns.estadoFuncional)) {
      return {
        section: 'S',
        confidence: 0.9,
        reasoning: 'Estado funcional reportado por paciente',
        entities
      };
    }
    
    // HISTORIA CLÃNICA â†’ S
    if (this.matchesPatterns(text, this.medicalPatterns.historiaClinica)) {
      return {
        section: 'S',
        confidence: 0.85,
        reasoning: 'Historia clÃ­nica del paciente',
        entities
      };
    }
    
    // DEFAULT PARA PACIENTE
    return {
      section: 'S',
      confidence: 0.7,
      reasoning: 'InformaciÃ³n subjetiva general del paciente',
      entities
    };
  }

  // === CLASIFICACIÃ“N ESPECÃFICA PARA TERAPEUTA ===
  
  private classifyTherapistStatement(text: string, entities: MedicalEntities): ClassificationResult {
    
    // EXAMEN FÃSICO â†’ O (Alta confianza)
    if (this.matchesPatterns(text, this.medicalPatterns.examenFisico)) {
      return {
        section: 'O',
        confidence: 0.95,
        reasoning: 'Examen fÃ­sico realizado por terapeuta',
        entities
      };
    }
    
    // INSTRUCCIONES DE EXAMEN â†’ O
    if (this.matchesPatterns(text, this.medicalPatterns.instruccionesExamen)) {
      return {
        section: 'O',
        confidence: 0.9,
        reasoning: 'Instrucciones durante examen fÃ­sico',
        entities
      };
    }
    
    // EVALUACIÃ“N CLÃNICA â†’ A
    if (this.matchesPatterns(text, this.medicalPatterns.evaluacionClinica)) {
      return {
        section: 'A',
        confidence: 0.95,
        reasoning: 'EvaluaciÃ³n clÃ­nica del terapeuta',
        entities
      };
    }
    
    // PLAN DE TRATAMIENTO â†’ P
    if (this.matchesPatterns(text, this.medicalPatterns.planTratamiento)) {
      return {
        section: 'P',
        confidence: 0.95,
        reasoning: 'Plan de tratamiento propuesto',
        entities
      };
    }
    
    // OBSERVACIONES GENERALES â†’ O
    if (this.matchesPatterns(text, this.medicalPatterns.observaciones)) {
      return {
        section: 'O',
        confidence: 0.8,
        reasoning: 'Observaciones del terapeuta',
        entities
      };
    }
    
    // DEFAULT PARA TERAPEUTA
    return {
      section: 'O',
      confidence: 0.6,
      reasoning: 'ObservaciÃ³n general del terapeuta',
      entities
    };
  }

  // === 2. PATRONES MÃ‰DICOS ESPECÃFICOS MEJORADOS ===
  
  private medicalPatterns = {
    // PATRONES PARA PACIENTE â†’ S
    sintomasSubjetivos: [
      /me duele|siento dolor|molesta|duele cuando/i,
      /tengo (dolor|molestia|sensaciÃ³n|hormigueo)/i,
      /me cuesta (hacer|mover|caminar|dormir)/i,
      /no puedo (hacer|mover|levantar|girar)/i,
      /siento (que|como|una|debilidad|rigidez)/i,
      /es (difÃ­cil|imposible|complicado|doloroso)/i
    ],
    
    estadoFuncional: [
      /en mi trabajo|en casa|cuando duermo/i,
      /antes podÃ­a|ahora no puedo|ya no puedo/i,
      /ha mejorado|ha empeorado|sigue igual/i,
      /afecta mi (vida|trabajo|sueÃ±o|actividad)/i,
      /desde hace (dÃ­as|semanas|meses|aÃ±os)/i,
      /comenzÃ³|empezÃ³|iniciÃ³|aparece/i
    ],
    
    historiaClinica: [
      /hace (tiempo|dÃ­as|semanas|meses)/i,
      /despuÃ©s de|desde que|cuando/i,
      /me pasÃ³|me ocurriÃ³|tuve un/i,
      /antecedentes|historia de|previo/i
    ],
    
    // PATRONES PARA TERAPEUTA â†’ O
    examenFisico: [
      /observo|veo que|palpo|examino|evalÃºo/i,
      /flexiÃ³n|extensiÃ³n|rotaciÃ³n|abducciÃ³n|aducciÃ³n/i,
      /rango de movimiento|movilidad|amplitud/i,
      /tono muscular|fuerza|estabilidad|resistencia/i,
      /palpaciÃ³n|inspecciÃ³n|valoraciÃ³n fÃ­sica/i,
      /test de|prueba de|maniobra de/i,
      /grados|centÃ­metros|mediciÃ³n|escala/i,
      /contractura|espasmo|tensiÃ³n muscular/i
    ],
    
    instruccionesExamen: [
      /flexione|extienda|gire|levante|baje/i,
      /presione|empuje|relaja|mantenga|sostenga/i,
      /dÃ­game si|avÃ­seme cuando|pare si/i,
      /realice|haga|ejecute|repita/i,
      /vamos a (evaluar|examinar|revisar|probar)/i
    ],
    
    // PATRONES PARA TERAPEUTA â†’ A
    evaluacionClinica: [
      /diagnÃ³stico|impresiÃ³n clÃ­nica|evaluaciÃ³n/i,
      /considero que|creo que|mi impresiÃ³n/i,
      /compatible con|sugiere|indica|apunta a/i,
      /anÃ¡lisis|interpretaciÃ³n|conclusiÃ³n/i,
      /estado|condiciÃ³n|situaciÃ³n clÃ­nica/i,
      /cuadro|sÃ­ndrome|patologÃ­a/i,
      /limitaciÃ³n|restricciÃ³n|disfunciÃ³n/i
    ],
    
    // PATRONES PARA TERAPEUTA â†’ P
    planTratamiento: [
      /recomiendo|sugiero|propongo|indico/i,
      /vamos a (hacer|aplicar|trabajar|iniciar)/i,
      /tratamiento|terapia|ejercicios|rehabilitaciÃ³n/i,
      /plan|protocolo|programa|rutina/i,
      /prÃ³xima sesiÃ³n|seguimiento|control/i,
      /objetivos|metas|resultados esperados/i,
      /fisioterapia|kinesioterapia|cinesiterapia/i,
      /ejercicio|estiramiento|fortalecimiento/i
    ],
    
    observaciones: [
      /presenta|muestra|evidencia|demuestra/i,
      /se observa|se aprecia|se nota/i,
      /paciente refiere|paciente manifiesta/i
    ]
  };

  // === 3. AUTO-COMPLETADO INTELIGENTE DE ASSESSMENT ===
  
  public generateAssessment(subjective: SOAPSegment[], objective: SOAPSegment[]): string {
    const symptoms = subjective.map(s => s.text).join(' ').toLowerCase();
    const findings = objective.map(o => o.text).join(' ').toLowerCase();
    
    // Extraer entidades clave
    const allEntities = this.combineEntities([...subjective, ...objective]);
    
    // ALGORITMO DE GENERACIÃ“N BASADO EN PATRONES CLÃNICOS
    
    // Caso 1: Problemas de hombro
    if (this.hasAnatomyAndSymptom(allEntities, ['hombro'], ['dolor']) || 
        symptoms.includes('hombro') && symptoms.includes('dolor')) {
      
      if (findings.includes('limitaciÃ³n') || findings.includes('movilidad')) {
        return 'LimitaciÃ³n funcional de hombro derecho con dolor asociado a movimientos de elevaciÃ³n. Compatible con sÃ­ndrome de pinzamiento subacromial.';
      }
      
      return 'Dolor de hombro con limitaciÃ³n funcional. Requiere evaluaciÃ³n de movilidad y fuerza para determinar origen especÃ­fico.';
    }
    
    // Caso 2: Problemas lumbares
    if (this.hasAnatomyAndSymptom(allEntities, ['espalda', 'lumbar'], ['dolor']) ||
        symptoms.includes('espalda baja') || symptoms.includes('lumbar')) {
      
      if (symptoms.includes('rigidez') || findings.includes('contractura')) {
        return 'Lumbalgia mecÃ¡nica con contractura paravertebral y rigidez matinal. Compatible con sÃ­ndrome facetario.';
      }
      
      return 'Lumbalgia de caracterÃ­sticas mecÃ¡nicas. EvaluaciÃ³n sugiere origen muscular con componente postural.';
    }
    
    // Caso 3: Problemas de rodilla
    if (this.hasAnatomyAndSymptom(allEntities, ['rodilla'], ['dolor']) ||
        symptoms.includes('rodilla')) {
      
      return 'Gonalgia con limitaciÃ³n funcional. Requiere evaluaciÃ³n de estabilidad ligamentaria y funciÃ³n meniscal.';
    }
    
    // Caso 4: Problemas cervicales
    if (this.hasAnatomyAndSymptom(allEntities, ['cuello', 'cervical'], ['dolor']) ||
        symptoms.includes('cuello')) {
      
      return 'Cervicalgia con restricciÃ³n de movilidad. Compatible con sÃ­ndrome cervical superior de origen postural.';
    }
    
    // Caso genÃ©rico basado en sÃ­ntomas principales
    const mainSymptoms = allEntities.sintomas.slice(0, 2);
    const mainAnatomy = allEntities.anatomia.slice(0, 2);
    
    if (mainSymptoms.length > 0 && mainAnatomy.length > 0) {
      return `Cuadro de ${mainSymptoms.join(' y ')} en ${mainAnatomy.join(' y ')}. EvaluaciÃ³n compatible con disfunciÃ³n musculoesquelÃ©tica que requiere abordaje fisioterapÃ©utico.`;
    }
    
    // Fallback genÃ©rico
    return 'EvaluaciÃ³n compatible con cuadro musculoesquelÃ©tico funcional. Requiere tratamiento fisioterapÃ©utico para optimizaciÃ³n de funciÃ³n y control de sÃ­ntomas.';
  }

  // === 4. IDENTIFICACIÃ“N DE HABLANTE MEJORADA ===
  
  public guessSpeaker(text: string): 'PATIENT' | 'THERAPIST' {
    const lower = text.toLowerCase().trim();
    
    // PATRONES FUERTES PARA PACIENTE
    const patientPatterns = [
      /^(me|yo|mi|siento|tengo|no puedo|me duele)/i,
      /me (duele|cuesta|molesta|pasa|ocurre)/i,
      /cuando (camino|duermo|trabajo|me muevo)/i,
      /desde hace|hace tiempo|antes podÃ­a/i
    ];
    
    // PATRONES FUERTES PARA TERAPEUTA
    const therapistPatterns = [
      /^(vamos a|necesito que|flexione|extienda)/i,
      /recomiendo|sugiero|indico|propongo/i,
      /observo|palpo|evalÃºo|examino/i,
      /vamos a (hacer|evaluar|trabajar|aplicar)/i,
      /el tratamiento|la terapia|el ejercicio/i
    ];
    
    // Calcular puntuaciones
    const patientScore = patientPatterns.reduce((score, pattern) => 
      pattern.test(lower) ? score + 2 : score, 0
    );
    
    const therapistScore = therapistPatterns.reduce((score, pattern) => 
      pattern.test(lower) ? score + 2 : score, 0
    );
    
    // DecisiÃ³n con umbral de confianza
    if (therapistScore > patientScore && therapistScore >= 2) {
      return 'THERAPIST';
    } else if (patientScore > therapistScore && patientScore >= 2) {
      return 'PATIENT';
    }
    
    // AnÃ¡lisis por palabras clave como fallback
    const therapistKeywords = ['evaluar', 'examinar', 'recomiendo', 'tratamiento', 'ejercicio', 'terapia'];
    const patientKeywords = ['duele', 'siento', 'me', 'mi', 'no puedo', 'me cuesta'];
    
    const therapistKeywordCount = therapistKeywords.reduce((count, keyword) => 
      lower.includes(keyword) ? count + 1 : count, 0
    );
    
    const patientKeywordCount = patientKeywords.reduce((count, keyword) => 
      lower.includes(keyword) ? count + 1 : count, 0
    );
    
    if (therapistKeywordCount > patientKeywordCount) return 'THERAPIST';
    if (patientKeywordCount > therapistKeywordCount) return 'PATIENT';
    
    // Default: PATIENT (mÃ¡s conservador para capturar sÃ­ntomas)
    return 'PATIENT';
  }

  // === 5. EXTRACCIÃ“N DE ENTIDADES MÃ‰DICAS MEJORADA ===
  
  public extractMedicalEntities(text: string): MedicalEntities {
    const lower = text.toLowerCase();
    
    // ANATOMÃA ESPECÃFICA DE FISIOTERAPIA
    const anatomyTerms = [
      'hombro', 'hombros', 'deltoides', 'manguito rotador',
      'rodilla', 'rodillas', 'rÃ³tula', 'menisco',
      'espalda', 'columna', 'vÃ©rtebra', 'disco',
      'lumbar', 'lumbares', 'sacro', 'coxis',
      'cervical', 'cervicales', 'cuello',
      'dorsal', 'dorsales', 'torÃ¡cica',
      'codo', 'codos', 'epicÃ³ndilo',
      'muÃ±eca', 'muÃ±ecas', 'carpo',
      'tobillo', 'tobillos', 'calcÃ¡neo',
      'cadera', 'caderas', 'pelvis',
      'brazo', 'brazos', 'antebrazo',
      'pierna', 'piernas', 'muslo',
      'pie', 'pies', 'planta del pie'
    ];
    
    // SÃNTOMAS ESPECÃFICOS DE FISIOTERAPIA
    const symptomTerms = [
      'dolor', 'molestia', 'malestar',
      'rigidez', 'tensiÃ³n', 'contractura',
      'debilidad', 'pÃ©rdida de fuerza',
      'hormigueo', 'entumecimiento', 'adormecimiento',
      'inflamaciÃ³n', 'hinchazÃ³n', 'edema',
      'limitaciÃ³n', 'restricciÃ³n', 'bloqueo',
      'inestabilidad', 'inseguridad',
      'fatiga', 'cansancio', 'agotamiento',
      'espasmo', 'calambre', 'rampa',
      'quemazÃ³n', 'ardor', 'pinchazos'
    ];
    
    // PROCEDIMIENTOS DE FISIOTERAPIA
    const procedureTerms = [
      'movilizaciÃ³n', 'manipulaciÃ³n',
      'estiramiento', 'elongaciÃ³n',
      'fortalecimiento', 'tonificaciÃ³n',
      'masoterapia', 'masaje',
      'electroterapia', 'ultrasonido',
      'termoterapia', 'crioterapia',
      'ejercicio', 'ejercicios',
      'rehabilitaciÃ³n', 'reeducaciÃ³n',
      'fisioterapia', 'kinesioterapia',
      'terapia manual', 'osteopatÃ­a',
      'pilates', 'yoga terapÃ©utico',
      'hidroterapia', 'aquaterapia'
    ];
    
    // MEDICAMENTOS COMUNES EN FISIOTERAPIA
    const medicationTerms = [
      'paracetamol', 'acetaminofÃ©n',
      'ibuprofeno', 'advil', 'nurofen',
      'diclofenaco', 'voltaren',
      'naproxeno', 'flanax',
      'tramadol', 'tramal',
      'relajante muscular', 'miorrelajante',
      'antiinflamatorio', 'aine',
      'analgÃ©sico', 'calmante',
      'corticoide', 'cortisona',
      'gel', 'pomada', 'crema'
    ];
    
    // FUNCIÃ“N AUXILIAR PARA BUSCAR TÃ‰RMINOS
    const findTerms = (terms: string[], text: string): string[] => {
      return terms.filter(term => {
        const regex = new RegExp(`\\b${term}\\b`, 'i');
        return regex.test(text);
      });
    };
    
    return {
      anatomia: findTerms(anatomyTerms, lower),
      sintomas: findTerms(symptomTerms, lower),
      procedimientos: findTerms(procedureTerms, lower),
      medicamentos: findTerms(medicationTerms, lower)
    };
  }

  // === MÃ‰TODOS AUXILIARES ===
  
  private matchesPatterns(text: string, patterns: RegExp[]): boolean {
    return patterns.some(pattern => pattern.test(text));
  }
  
  private hasAnatomyAndSymptom(entities: MedicalEntities, anatomy: string[], symptoms: string[]): boolean {
    const hasAnatomy = anatomy.some(a => entities.anatomia.includes(a));
    const hasSymptom = symptoms.some(s => entities.sintomas.includes(s));
    return hasAnatomy && hasSymptom;
  }
  
  private combineEntities(segments: SOAPSegment[]): MedicalEntities {
    const combined: MedicalEntities = {
      anatomia: [],
      sintomas: [],
      procedimientos: [],
      medicamentos: []
    };
    
    segments.forEach(segment => {
      combined.anatomia.push(...segment.classification.entities.anatomia);
      combined.sintomas.push(...segment.classification.entities.sintomas);
      combined.procedimientos.push(...segment.classification.entities.procedimientos);
      combined.medicamentos.push(...segment.classification.entities.medicamentos);
    });
    
    // Eliminar duplicados
    combined.anatomia = [...new Set(combined.anatomia)];
    combined.sintomas = [...new Set(combined.sintomas)];
    combined.procedimientos = [...new Set(combined.procedimientos)];
    combined.medicamentos = [...new Set(combined.medicamentos)];
    
    return combined;
  }

  // === MÃ‰TODO PRINCIPAL PARA PROCESAR CONVERSACIÃ“N COMPLETA ===
  
  public processConversation(segments: Array<{
    id: string;
    text: string;
    speaker: 'PATIENT' | 'THERAPIST' | 'UNKNOWN';
    timestamp: number;
  }>): CompletedSOAP {
    
    // Clasificar todos los segmentos
    const classifiedSegments: SOAPSegment[] = segments.map(segment => ({
      ...segment,
      classification: this.classifySOAPSegment(segment.text, segment.speaker)
    }));
    
    // Organizar por secciones
    const subjective = classifiedSegments.filter(s => s.classification.section === 'S');
    const objective = classifiedSegments.filter(s => s.classification.section === 'O');
    const assessment_segments = classifiedSegments.filter(s => s.classification.section === 'A');
    const plan = classifiedSegments.filter(s => s.classification.section === 'P');
    
    // Generar Assessment si no existe o es insuficiente
    let assessment: string;
    let autoGeneratedAssessment = false;
    
    if (assessment_segments.length === 0 || assessment_segments.every(a => a.text.length < 20)) {
      assessment = this.generateAssessment(subjective, objective);
      autoGeneratedAssessment = true;
    } else {
      assessment = assessment_segments.map(a => a.text).join('. ');
    }
    
    // Calcular mÃ©tricas
    const totalSegments = classifiedSegments.length;
    const averageConfidence = classifiedSegments.reduce((sum, s) => 
      sum + s.classification.confidence, 0) / totalSegments;
    
    // Extraer hallazgos clave
    const allEntities = this.combineEntities(classifiedSegments);
    const keyFindings = [
      ...allEntities.anatomia.slice(0, 2).map(a => `Ãrea afectada: ${a}`),
      ...allEntities.sintomas.slice(0, 2).map(s => `SÃ­ntoma: ${s}`),
      ...allEntities.procedimientos.slice(0, 1).map(p => `Procedimiento: ${p}`)
    ];
    
    return {
      subjective,
      objective,
      assessment,
      plan,
      summary: {
        totalSegments,
        confidence: Math.round(averageConfidence * 100) / 100,
        keyFindings,
        autoGeneratedAssessment
      }
    };
  }
}

export default AdvancedSOAPClassifier;