/**
 * 🧠 ADVANCED SOAP CLASSIFIER - Clasificador SOAP Avanzado
 * 
 * Basado en recomendaciones de ChatGPT para mejorar la clasificación
 * automática de conversaciones médicas en secciones S.O.A.P.
 * 
 * Optimizado específicamente para fisioterapia/rehabilitación
 * 
 * @author AiDuxCare Team + ChatGPT Optimization
 * @date Junio 2025
 * @version 3.0
 */

// === INTERFACES ===

export interface ClassificationResult {
  section: 'S' | 'O' | 'A' | 'P';
  confidence: number;
  reasoning: string;
  entities: MedicalEntities;
}

export interface MedicalEntities {
  anatomia: string[];
  sintomas: string[];
  procedimientos: string[];
  medicamentos: string[];
}

export interface SOAPSegment {
  id: string;
  text: string;
  speaker: 'PATIENT' | 'THERAPIST' | 'UNKNOWN';
  classification: ClassificationResult;
  timestamp: number;
}

export interface CompletedSOAP {
  subjective: SOAPSegment[];
  objective: SOAPSegment[];
  assessment: string;
  plan: SOAPSegment[];
  summary: {
    totalSegments: number;
    confidence: number;
    keyFindings: string[];
    autoGeneratedAssessment: boolean;
  };
}

// === CLASIFICADOR PRINCIPAL ===

export class AdvancedSOAPClassifier {
  
  // === 1. ALGORITMO NLP MEJORADO PARA CLASIFICACIÓN SOAP ===
  
  public classifySOAPSegment(text: string, speaker: 'PATIENT' | 'THERAPIST' | 'UNKNOWN'): ClassificationResult {
    const lower = text.toLowerCase().trim();
    
    // Extraer entidades médicas primero
    const entities = this.extractMedicalEntities(text);
    
    // Clasificación por hablante con patrones específicos
    if (speaker === 'PATIENT') {
      return this.classifyPatientStatement(lower, entities);
    } else if (speaker === 'THERAPIST') {
      return this.classifyTherapistStatement(lower, entities);
    } else {
      // Inferir hablante y clasificar
      const inferredSpeaker = this.guessSpeaker(text);
      return this.classifySOAPSegment(text, inferredSpeaker);
    }
  }

  // === CLASIFICACIÓN ESPECÍFICA PARA PACIENTE ===
  
  private classifyPatientStatement(text: string, entities: MedicalEntities): ClassificationResult {
    
    // SÍNTOMAS Y SENSACIONES → S (Alta confianza)
    if (this.matchesPatterns(text, this.medicalPatterns.sintomasSubjetivos)) {
      return {
        section: 'S',
        confidence: 0.95,
        reasoning: 'Síntomas subjetivos reportados por paciente',
        entities
      };
    }
    
    // INFORMACIÓN FUNCIONAL → S
    if (this.matchesPatterns(text, this.medicalPatterns.estadoFuncional)) {
      return {
        section: 'S',
        confidence: 0.9,
        reasoning: 'Estado funcional reportado por paciente',
        entities
      };
    }
    
    // HISTORIA CLÍNICA → S
    if (this.matchesPatterns(text, this.medicalPatterns.historiaClinica)) {
      return {
        section: 'S',
        confidence: 0.85,
        reasoning: 'Historia clínica del paciente',
        entities
      };
    }
    
    // DEFAULT PARA PACIENTE
    return {
      section: 'S',
      confidence: 0.7,
      reasoning: 'Información subjetiva general del paciente',
      entities
    };
  }

  // === CLASIFICACIÓN ESPECÍFICA PARA TERAPEUTA ===
  
  private classifyTherapistStatement(text: string, entities: MedicalEntities): ClassificationResult {
    
    // EXAMEN FÍSICO → O (Alta confianza)
    if (this.matchesPatterns(text, this.medicalPatterns.examenFisico)) {
      return {
        section: 'O',
        confidence: 0.95,
        reasoning: 'Examen físico realizado por terapeuta',
        entities
      };
    }
    
    // INSTRUCCIONES DE EXAMEN → O
    if (this.matchesPatterns(text, this.medicalPatterns.instruccionesExamen)) {
      return {
        section: 'O',
        confidence: 0.9,
        reasoning: 'Instrucciones durante examen físico',
        entities
      };
    }
    
    // EVALUACIÓN CLÍNICA → A
    if (this.matchesPatterns(text, this.medicalPatterns.evaluacionClinica)) {
      return {
        section: 'A',
        confidence: 0.95,
        reasoning: 'Evaluación clínica del terapeuta',
        entities
      };
    }
    
    // PLAN DE TRATAMIENTO → P
    if (this.matchesPatterns(text, this.medicalPatterns.planTratamiento)) {
      return {
        section: 'P',
        confidence: 0.95,
        reasoning: 'Plan de tratamiento propuesto',
        entities
      };
    }
    
    // OBSERVACIONES GENERALES → O
    if (this.matchesPatterns(text, this.medicalPatterns.observaciones)) {
      return {
        section: 'O',
        confidence: 0.8,
        reasoning: 'Observaciones del terapeuta',
        entities
      };
    }
    
    // DEFAULT PARA TERAPEUTA
    return {
      section: 'O',
      confidence: 0.6,
      reasoning: 'Observación general del terapeuta',
      entities
    };
  }

  // === 2. PATRONES MÉDICOS ESPECÍFICOS MEJORADOS ===
  
  private medicalPatterns = {
    // PATRONES PARA PACIENTE → S
    sintomasSubjetivos: [
      /me duele|siento dolor|molesta|duele cuando/i,
      /tengo (dolor|molestia|sensación|hormigueo)/i,
      /me cuesta (hacer|mover|caminar|dormir)/i,
      /no puedo (hacer|mover|levantar|girar)/i,
      /siento (que|como|una|debilidad|rigidez)/i,
      /es (difícil|imposible|complicado|doloroso)/i
    ],
    
    estadoFuncional: [
      /en mi trabajo|en casa|cuando duermo/i,
      /antes podía|ahora no puedo|ya no puedo/i,
      /ha mejorado|ha empeorado|sigue igual/i,
      /afecta mi (vida|trabajo|sueño|actividad)/i,
      /desde hace (días|semanas|meses|años)/i,
      /comenzó|empezó|inició|aparece/i
    ],
    
    historiaClinica: [
      /hace (tiempo|días|semanas|meses)/i,
      /después de|desde que|cuando/i,
      /me pasó|me ocurrió|tuve un/i,
      /antecedentes|historia de|previo/i
    ],
    
    // PATRONES PARA TERAPEUTA → O
    examenFisico: [
      /observo|veo que|palpo|examino|evalúo/i,
      /flexión|extensión|rotación|abducción|aducción/i,
      /rango de movimiento|movilidad|amplitud/i,
      /tono muscular|fuerza|estabilidad|resistencia/i,
      /palpación|inspección|valoración física/i,
      /test de|prueba de|maniobra de/i,
      /grados|centímetros|medición|escala/i,
      /contractura|espasmo|tensión muscular/i
    ],
    
    instruccionesExamen: [
      /flexione|extienda|gire|levante|baje/i,
      /presione|empuje|relaja|mantenga|sostenga/i,
      /dígame si|avíseme cuando|pare si/i,
      /realice|haga|ejecute|repita/i,
      /vamos a (evaluar|examinar|revisar|probar)/i
    ],
    
    // PATRONES PARA TERAPEUTA → A
    evaluacionClinica: [
      /diagnóstico|impresión clínica|evaluación/i,
      /considero que|creo que|mi impresión/i,
      /compatible con|sugiere|indica|apunta a/i,
      /análisis|interpretación|conclusión/i,
      /estado|condición|situación clínica/i,
      /cuadro|síndrome|patología/i,
      /limitación|restricción|disfunción/i
    ],
    
    // PATRONES PARA TERAPEUTA → P
    planTratamiento: [
      /recomiendo|sugiero|propongo|indico/i,
      /vamos a (hacer|aplicar|trabajar|iniciar)/i,
      /tratamiento|terapia|ejercicios|rehabilitación/i,
      /plan|protocolo|programa|rutina/i,
      /próxima sesión|seguimiento|control/i,
      /objetivos|metas|resultados esperados/i,
      /fisioterapia|kinesioterapia|cinesiterapia/i,
      /ejercicio|estiramiento|fortalecimiento/i
    ],
    
    observaciones: [
      /presenta|muestra|evidencia|demuestra/i,
      /se observa|se aprecia|se nota/i,
      /paciente refiere|paciente manifiesta/i
    ]
  };

  // === 3. AUTO-COMPLETADO INTELIGENTE DE ASSESSMENT ===
  
  public generateAssessment(subjective: SOAPSegment[], objective: SOAPSegment[]): string {
    const symptoms = subjective.map(s => s.text).join(' ').toLowerCase();
    const findings = objective.map(o => o.text).join(' ').toLowerCase();
    
    // Extraer entidades clave
    const allEntities = this.combineEntities([...subjective, ...objective]);
    
    // ALGORITMO DE GENERACIÓN BASADO EN PATRONES CLÍNICOS
    
    // Caso 1: Problemas de hombro
    if (this.hasAnatomyAndSymptom(allEntities, ['hombro'], ['dolor']) || 
        symptoms.includes('hombro') && symptoms.includes('dolor')) {
      
      if (findings.includes('limitación') || findings.includes('movilidad')) {
        return 'Limitación funcional de hombro derecho con dolor asociado a movimientos de elevación. Compatible con síndrome de pinzamiento subacromial.';
      }
      
      return 'Dolor de hombro con limitación funcional. Requiere evaluación de movilidad y fuerza para determinar origen específico.';
    }
    
    // Caso 2: Problemas lumbares
    if (this.hasAnatomyAndSymptom(allEntities, ['espalda', 'lumbar'], ['dolor']) ||
        symptoms.includes('espalda baja') || symptoms.includes('lumbar')) {
      
      if (symptoms.includes('rigidez') || findings.includes('contractura')) {
        return 'Lumbalgia mecánica con contractura paravertebral y rigidez matinal. Compatible con síndrome facetario.';
      }
      
      return 'Lumbalgia de características mecánicas. Evaluación sugiere origen muscular con componente postural.';
    }
    
    // Caso 3: Problemas de rodilla
    if (this.hasAnatomyAndSymptom(allEntities, ['rodilla'], ['dolor']) ||
        symptoms.includes('rodilla')) {
      
      return 'Gonalgia con limitación funcional. Requiere evaluación de estabilidad ligamentaria y función meniscal.';
    }
    
    // Caso 4: Problemas cervicales
    if (this.hasAnatomyAndSymptom(allEntities, ['cuello', 'cervical'], ['dolor']) ||
        symptoms.includes('cuello')) {
      
      return 'Cervicalgia con restricción de movilidad. Compatible con síndrome cervical superior de origen postural.';
    }
    
    // Caso genérico basado en síntomas principales
    const mainSymptoms = allEntities.sintomas.slice(0, 2);
    const mainAnatomy = allEntities.anatomia.slice(0, 2);
    
    if (mainSymptoms.length > 0 && mainAnatomy.length > 0) {
      return `Cuadro de ${mainSymptoms.join(' y ')} en ${mainAnatomy.join(' y ')}. Evaluación compatible con disfunción musculoesquelética que requiere abordaje fisioterapéutico.`;
    }
    
    // Fallback genérico
    return 'Evaluación compatible con cuadro musculoesquelético funcional. Requiere tratamiento fisioterapéutico para optimización de función y control de síntomas.';
  }

  // === 4. IDENTIFICACIÓN DE HABLANTE MEJORADA ===
  
  public guessSpeaker(text: string): 'PATIENT' | 'THERAPIST' {
    const lower = text.toLowerCase().trim();
    
    // PATRONES FUERTES PARA PACIENTE
    const patientPatterns = [
      /^(me|yo|mi|siento|tengo|no puedo|me duele)/i,
      /me (duele|cuesta|molesta|pasa|ocurre)/i,
      /cuando (camino|duermo|trabajo|me muevo)/i,
      /desde hace|hace tiempo|antes podía/i
    ];
    
    // PATRONES FUERTES PARA TERAPEUTA
    const therapistPatterns = [
      /^(vamos a|necesito que|flexione|extienda)/i,
      /recomiendo|sugiero|indico|propongo/i,
      /observo|palpo|evalúo|examino/i,
      /vamos a (hacer|evaluar|trabajar|aplicar)/i,
      /el tratamiento|la terapia|el ejercicio/i
    ];
    
    // Calcular puntuaciones
    const patientScore = patientPatterns.reduce((score, pattern) => 
      pattern.test(lower) ? score + 2 : score, 0
    );
    
    const therapistScore = therapistPatterns.reduce((score, pattern) => 
      pattern.test(lower) ? score + 2 : score, 0
    );
    
    // Decisión con umbral de confianza
    if (therapistScore > patientScore && therapistScore >= 2) {
      return 'THERAPIST';
    } else if (patientScore > therapistScore && patientScore >= 2) {
      return 'PATIENT';
    }
    
    // Análisis por palabras clave como fallback
    const therapistKeywords = ['evaluar', 'examinar', 'recomiendo', 'tratamiento', 'ejercicio', 'terapia'];
    const patientKeywords = ['duele', 'siento', 'me', 'mi', 'no puedo', 'me cuesta'];
    
    const therapistKeywordCount = therapistKeywords.reduce((count, keyword) => 
      lower.includes(keyword) ? count + 1 : count, 0
    );
    
    const patientKeywordCount = patientKeywords.reduce((count, keyword) => 
      lower.includes(keyword) ? count + 1 : count, 0
    );
    
    if (therapistKeywordCount > patientKeywordCount) return 'THERAPIST';
    if (patientKeywordCount > therapistKeywordCount) return 'PATIENT';
    
    // Default: PATIENT (más conservador para capturar síntomas)
    return 'PATIENT';
  }

  // === 5. EXTRACCIÓN DE ENTIDADES MÉDICAS MEJORADA ===
  
  public extractMedicalEntities(text: string): MedicalEntities {
    const lower = text.toLowerCase();
    
    // ANATOMÍA ESPECÍFICA DE FISIOTERAPIA
    const anatomyTerms = [
      'hombro', 'hombros', 'deltoides', 'manguito rotador',
      'rodilla', 'rodillas', 'rótula', 'menisco',
      'espalda', 'columna', 'vértebra', 'disco',
      'lumbar', 'lumbares', 'sacro', 'coxis',
      'cervical', 'cervicales', 'cuello',
      'dorsal', 'dorsales', 'torácica',
      'codo', 'codos', 'epicóndilo',
      'muñeca', 'muñecas', 'carpo',
      'tobillo', 'tobillos', 'calcáneo',
      'cadera', 'caderas', 'pelvis',
      'brazo', 'brazos', 'antebrazo',
      'pierna', 'piernas', 'muslo',
      'pie', 'pies', 'planta del pie'
    ];
    
    // SÍNTOMAS ESPECÍFICOS DE FISIOTERAPIA
    const symptomTerms = [
      'dolor', 'molestia', 'malestar',
      'rigidez', 'tensión', 'contractura',
      'debilidad', 'pérdida de fuerza',
      'hormigueo', 'entumecimiento', 'adormecimiento',
      'inflamación', 'hinchazón', 'edema',
      'limitación', 'restricción', 'bloqueo',
      'inestabilidad', 'inseguridad',
      'fatiga', 'cansancio', 'agotamiento',
      'espasmo', 'calambre', 'rampa',
      'quemazón', 'ardor', 'pinchazos'
    ];
    
    // PROCEDIMIENTOS DE FISIOTERAPIA
    const procedureTerms = [
      'movilización', 'manipulación',
      'estiramiento', 'elongación',
      'fortalecimiento', 'tonificación',
      'masoterapia', 'masaje',
      'electroterapia', 'ultrasonido',
      'termoterapia', 'crioterapia',
      'ejercicio', 'ejercicios',
      'rehabilitación', 'reeducación',
      'fisioterapia', 'kinesioterapia',
      'terapia manual', 'osteopatía',
      'pilates', 'yoga terapéutico',
      'hidroterapia', 'aquaterapia'
    ];
    
    // MEDICAMENTOS COMUNES EN FISIOTERAPIA
    const medicationTerms = [
      'paracetamol', 'acetaminofén',
      'ibuprofeno', 'advil', 'nurofen',
      'diclofenaco', 'voltaren',
      'naproxeno', 'flanax',
      'tramadol', 'tramal',
      'relajante muscular', 'miorrelajante',
      'antiinflamatorio', 'aine',
      'analgésico', 'calmante',
      'corticoide', 'cortisona',
      'gel', 'pomada', 'crema'
    ];
    
    // FUNCIÓN AUXILIAR PARA BUSCAR TÉRMINOS
    const findTerms = (terms: string[], text: string): string[] => {
      return terms.filter(term => {
        const regex = new RegExp(`\\b${term}\\b`, 'i');
        return regex.test(text);
      });
    };
    
    return {
      anatomia: findTerms(anatomyTerms, lower),
      sintomas: findTerms(symptomTerms, lower),
      procedimientos: findTerms(procedureTerms, lower),
      medicamentos: findTerms(medicationTerms, lower)
    };
  }

  // === MÉTODOS AUXILIARES ===
  
  private matchesPatterns(text: string, patterns: RegExp[]): boolean {
    return patterns.some(pattern => pattern.test(text));
  }
  
  private hasAnatomyAndSymptom(entities: MedicalEntities, anatomy: string[], symptoms: string[]): boolean {
    const hasAnatomy = anatomy.some(a => entities.anatomia.includes(a));
    const hasSymptom = symptoms.some(s => entities.sintomas.includes(s));
    return hasAnatomy && hasSymptom;
  }
  
  private combineEntities(segments: SOAPSegment[]): MedicalEntities {
    const combined: MedicalEntities = {
      anatomia: [],
      sintomas: [],
      procedimientos: [],
      medicamentos: []
    };
    
    segments.forEach(segment => {
      combined.anatomia.push(...segment.classification.entities.anatomia);
      combined.sintomas.push(...segment.classification.entities.sintomas);
      combined.procedimientos.push(...segment.classification.entities.procedimientos);
      combined.medicamentos.push(...segment.classification.entities.medicamentos);
    });
    
    // Eliminar duplicados
    combined.anatomia = [...new Set(combined.anatomia)];
    combined.sintomas = [...new Set(combined.sintomas)];
    combined.procedimientos = [...new Set(combined.procedimientos)];
    combined.medicamentos = [...new Set(combined.medicamentos)];
    
    return combined;
  }

  // === MÉTODO PRINCIPAL PARA PROCESAR CONVERSACIÓN COMPLETA ===
  
  public processConversation(segments: Array<{
    id: string;
    text: string;
    speaker: 'PATIENT' | 'THERAPIST' | 'UNKNOWN';
    timestamp: number;
  }>): CompletedSOAP {
    
    // Clasificar todos los segmentos
    const classifiedSegments: SOAPSegment[] = segments.map(segment => ({
      ...segment,
      classification: this.classifySOAPSegment(segment.text, segment.speaker)
    }));
    
    // Organizar por secciones
    const subjective = classifiedSegments.filter(s => s.classification.section === 'S');
    const objective = classifiedSegments.filter(s => s.classification.section === 'O');
    const assessment_segments = classifiedSegments.filter(s => s.classification.section === 'A');
    const plan = classifiedSegments.filter(s => s.classification.section === 'P');
    
    // Generar Assessment si no existe o es insuficiente
    let assessment: string;
    let autoGeneratedAssessment = false;
    
    if (assessment_segments.length === 0 || assessment_segments.every(a => a.text.length < 20)) {
      assessment = this.generateAssessment(subjective, objective);
      autoGeneratedAssessment = true;
    } else {
      assessment = assessment_segments.map(a => a.text).join('. ');
    }
    
    // Calcular métricas
    const totalSegments = classifiedSegments.length;
    const averageConfidence = classifiedSegments.reduce((sum, s) => 
      sum + s.classification.confidence, 0) / totalSegments;
    
    // Extraer hallazgos clave
    const allEntities = this.combineEntities(classifiedSegments);
    const keyFindings = [
      ...allEntities.anatomia.slice(0, 2).map(a => `Área afectada: ${a}`),
      ...allEntities.sintomas.slice(0, 2).map(s => `Síntoma: ${s}`),
      ...allEntities.procedimientos.slice(0, 1).map(p => `Procedimiento: ${p}`)
    ];
    
    return {
      subjective,
      objective,
      assessment,
      plan,
      summary: {
        totalSegments,
        confidence: Math.round(averageConfidence * 100) / 100,
        keyFindings,
        autoGeneratedAssessment
      }
    };
  }
}

export default AdvancedSOAPClassifier;