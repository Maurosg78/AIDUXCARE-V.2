/**
 * üîê Local Authentication Service - AiDuxCare V.2
 * Gesti√≥n de autenticaci√≥n local sin dependencias externas
 * Integrado con LocalStorageService para persistencia
 */

import { TherapistLocalData } from '@/types/session';
import { localStorageService } from './LocalStorageService';

export interface AuthenticationResult {
  success: boolean;
  therapist?: TherapistLocalData;
  error?: string;
}

export interface RegisterData {
  name: string;
  email?: string;
  specialization?: string;
  licenseNumber?: string;
}

class LocalAuthService {
  private currentSession: TherapistLocalData | null = null;

  constructor() {
    this.initializeSession();
  }

  // ========= INICIALIZACI√ìN =========

  /**
   * Inicializar sesi√≥n al cargar la aplicaci√≥n
   */
  private initializeSession(): void {
    const therapist = localStorageService.getCurrentTherapist();
    if (therapist) {
      this.currentSession = therapist;
    }
  }

  // ========= AUTENTICACI√ìN =========

  /**
   * Verificar si hay un usuario autenticado
   */
  isAuthenticated(): boolean {
    return this.currentSession !== null;
  }

  /**
   * Obtener terapeuta actualmente autenticado
   */
  getCurrentTherapist(): TherapistLocalData | null {
    return this.currentSession;
  }

  /**
   * Login simple (por nombre de terapeuta)
   */
  async authenticate(therapistName: string): Promise<AuthenticationResult> {
    try {
      // En modo local, buscamos o creamos el terapeuta
      let therapist = this.findTherapistByName(therapistName);
      
      if (!therapist) {
        // Si no existe, lo creamos autom√°ticamente
        therapist = localStorageService.createTherapist(
          this.generateTherapistId(therapistName),
          therapistName
        );
      }

      // Actualizar √∫ltimo acceso
      therapist.lastActiveAt = new Date().toISOString();
      localStorageService.saveTherapistData(therapist);

      // Establecer sesi√≥n actual
      this.currentSession = therapist;

      return {
        success: true,
        therapist
      };

    } catch (error) {
      console.error('‚ùå Error en autenticaci√≥n:', error);
      return {
        success: false,
        error: 'Error interno de autenticaci√≥n'
      };
    }
  }

  /**
   * Registro de nuevo terapeuta
   */
  async register(registerData: RegisterData): Promise<AuthenticationResult> {
    try {
      // Verificar si ya existe
      const existing = this.findTherapistByName(registerData.name);
      if (existing) {
        return {
          success: false,
          error: 'Ya existe un terapeuta con ese nombre'
        };
      }

      // Crear nuevo terapeuta
      const therapistId = this.generateTherapistId(registerData.name);
      const therapist = localStorageService.createTherapist(
        therapistId,
        registerData.name,
        registerData.email
      );

      // Agregar datos adicionales si se proporcionaron
      if (registerData.specialization || registerData.licenseNumber) {
        therapist.preferences = {
          ...therapist.preferences,
          specialization: registerData.specialization,
          licenseNumber: registerData.licenseNumber
        };
        localStorageService.saveTherapistData(therapist);
      }

      // Establecer sesi√≥n actual
      this.currentSession = therapist;

      return {
        success: true,
        therapist
      };

    } catch (error) {
      console.error('‚ùå Error en registro:', error);
      return {
        success: false,
        error: 'Error interno en el registro'
      };
    }
  }

  /**
   * Cambiar a otro terapeuta
   */
  async switchTherapist(therapistName: string): Promise<AuthenticationResult> {
    try {
      const therapist = this.findTherapistByName(therapistName);
      
      if (!therapist) {
        return {
          success: false,
          error: 'Terapeuta no encontrado'
        };
      }

      // Actualizar √∫ltimo acceso
      therapist.lastActiveAt = new Date().toISOString();
      localStorageService.saveTherapistData(therapist);

      // Cambiar sesi√≥n actual
      this.currentSession = therapist;

      return {
        success: true,
        therapist
      };

    } catch (error) {
      console.error('‚ùå Error al cambiar terapeuta:', error);
      return {
        success: false,
        error: 'Error interno al cambiar terapeuta'
      };
    }
  }

  /**
   * Cerrar sesi√≥n
   */
  logout(): void {
    this.currentSession = null;
    // No eliminamos datos del localStorage, solo la sesi√≥n actual
  }

  // ========= GESTI√ìN DE TERAPEUTAS =========

  /**
   * Obtener lista de todos los terapeutas registrados
   */
  getAllTherapists(): string[] {
    try {
      // En la implementaci√≥n actual, solo tenemos un terapeuta por vez
      // Esto se expandir√° cuando implementemos m√∫ltiples terapeutas
      const current = localStorageService.getCurrentTherapist();
      return current ? [current.name] : [];
    } catch (error) {
      console.error('‚ùå Error al obtener terapeutas:', error);
      return [];
    }
  }

  /**
   * Eliminar terapeuta (con confirmaci√≥n)
   */
  async deleteTherapist(therapistName: string): Promise<boolean> {
    try {
      const therapist = this.findTherapistByName(therapistName);
      if (!therapist) return false;

      // Si es el terapeuta actual, cerrar sesi√≥n
      if (this.currentSession?.name === therapistName) {
        this.logout();
      }

      // En la implementaci√≥n actual, esto equivale a limpiar el storage
      // Se expandir√° para manejar m√∫ltiples terapeutas
      if (therapist.name === localStorageService.getCurrentTherapist()?.name) {
        localStorage.removeItem('aiduxcare_v2_therapist_data');
        return true;
      }

      return false;
    } catch (error) {
      console.error('‚ùå Error al eliminar terapeuta:', error);
      return false;
    }
  }

  // ========= UTILIDADES PRIVADAS =========

  /**
   * Buscar terapeuta por nombre
   */
  private findTherapistByName(name: string): TherapistLocalData | null {
    const current = localStorageService.getCurrentTherapist();
    return current && current.name === name ? current : null;
  }

  /**
   * Generar ID √∫nico para terapeuta
   */
  private generateTherapistId(name: string): string {
    const timestamp = Date.now();
    const nameSlug = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
    return `therapist-${nameSlug}-${timestamp}`;
  }

  // ========= VALIDACIONES =========

  /**
   * Validar datos de registro
   */
  validateRegisterData(data: RegisterData): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!data.name || data.name.trim().length < 2) {
      errors.push('El nombre debe tener al menos 2 caracteres');
    }

    if (data.email && !this.isValidEmail(data.email)) {
      errors.push('El email no tiene un formato v√°lido');
    }

    if (data.name && data.name.trim().length > 50) {
      errors.push('El nombre no puede exceder 50 caracteres');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Validar formato de email
   */
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}

// Instancia singleton
export const localAuthService = new LocalAuthService();
export default LocalAuthService; 