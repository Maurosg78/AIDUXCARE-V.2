/**
 * AI: SMART SOAP PROCESSOR V3.0 - Procesador SOAP Inteligente Avanzado
 * 
 * Integra transcripción en tiempo real con clasificación SOAP automática
 * Soluciona el problema de "copy/paste" implementando IA real
 * 
 * MEJORAS V3.0 (ChatGPT Optimized):
 * SUCCESS: Clasificación inteligente por patrones semánticos
 * SUCCESS: Identificación de hablante mejorada
 * SUCCESS: Extracción de entidades médicas especializada en fisioterapia
 * SUCCESS: Auto-generación de Assessment basado en S+O
 * SUCCESS: Algoritmos contextuales por disciplina médica
 * 
 * @author AiDuxCare Team + ChatGPT Optimization
 * @date Junio 2025
 * @version 3.0
 */

// === IMPORTS ===
import AdvancedSOAPClassifier, { 
  SOAPSegment, 
  CompletedSOAP, 
  ClassificationResult,
  MedicalEntities 
} from './AdvancedSOAPClassifier';

// === INTERFACES LEGACY (Mantenidas para compatibilidad) ===

export interface TranscriptionSegment {
  id: string;
  text: string;
  speaker: 'PATIENT' | 'THERAPIST' | 'UNKNOWN';
  confidence: number;
  timestamp: number;
  isFinal: boolean;
}

export interface MedicalEntity {
  text: string;
  type: 'SYMPTOM' | 'ANATOMY' | 'MEDICATION' | 'CONDITION' | 'PROCEDURE' | 'MEASUREMENT';
  confidence: number;
  start: number;
  end: number;
  context?: string;
}

export interface SOAPSection {
  section: 'S' | 'O' | 'A' | 'P';
  content: string;
  confidence: number;
  originalText: string;
  entities: MedicalEntity[];
  speaker: string;
  timestamp: number;
  processed: boolean;
}

export interface SmartSOAPResult {
  subjective: SOAPSection[];
  objective: SOAPSection[];
  assessment: SOAPSection[];
  plan: SOAPSection[];
  summary: {
    totalSegments: number;
    processedSegments: number;
    confidence: number;
    keyFindings: string[];
    recommendations: string[];
    autoGeneratedAssessment?: boolean;
  };
  rawTranscription: TranscriptionSegment[];
  processingMetrics: {
    processingTime: number;
    aiClassifications: number;
    fallbackClassifications: number;
    entityExtractions: number;
    classifierVersion: string;
  };
}

// === PROCESADOR PRINCIPAL MEJORADO ===

export class SmartSOAPProcessor {
  private classifier: AdvancedSOAPClassifier;
  private geminiAvailable: boolean = false;
  private processingStats = {
    totalProcessed: 0,
    aiClassified: 0,
    fallbackClassified: 0,
    entitiesExtracted: 0
  };

  constructor() {
    this.classifier = new AdvancedSOAPClassifier();
    this.checkGeminiAvailability();
    console.log('LAUNCH: SmartSOAPProcessor V3.0 inicializado con AdvancedSOAPClassifier');
  }

  /**
   * Verificar si Gemini está disponible
   */
  private checkGeminiAvailability(): void {
    // TODO: Integrar con SOAPClassifierV2Service cuando esté listo
    this.geminiAvailable = false;
    console.log('BOT: Gemini 1.5 Pro no configurado - usando AdvancedSOAPClassifier local');
  }

  /**
   * FUNCIÓN PRINCIPAL MEJORADA: Procesar transcripción completa
   */
  async processTranscription(segments: TranscriptionSegment[]): Promise<SmartSOAPResult> {
    const startTime = Date.now();
    
    console.log(`RELOAD: Iniciando procesamiento inteligente V3.0 de ${segments.length} segmentos...`);

    // Filtrar solo segmentos finales
    const finalSegments = segments.filter(s => s.isFinal);
    
    // Convertir a formato del nuevo clasificador
    const classifierSegments = finalSegments.map(segment => ({
      id: segment.id,
      text: segment.text,
      speaker: segment.speaker,
      timestamp: segment.timestamp
    }));

    // USAR EL NUEVO CLASIFICADOR AVANZADO
    const completedSOAP: CompletedSOAP = this.classifier.processConversation(classifierSegments);

    // Convertir resultado a formato legacy para compatibilidad
    const legacyResult = this.convertToLegacyFormat(completedSOAP, segments);

    // Métricas de procesamiento
    const processingTime = Date.now() - startTime;
    
    const finalResult: SmartSOAPResult = {
      ...legacyResult,
      processingMetrics: {
        processingTime,
        aiClassifications: this.geminiAvailable ? completedSOAP.summary.totalSegments : 0,
        fallbackClassifications: this.geminiAvailable ? 0 : completedSOAP.summary.totalSegments,
        entityExtractions: this.countTotalEntities(completedSOAP),
        classifierVersion: 'AdvancedSOAPClassifier V3.0'
      }
    };

    console.log(`SUCCESS: Procesamiento V3.0 completado en ${processingTime}ms`);
    console.log(`STATS: Estadísticas: ${finalResult.summary.processedSegments} segmentos procesados`);
    console.log(`TARGET: Confianza promedio: ${Math.round(completedSOAP.summary.confidence * 100)}%`);
    
    return finalResult;
  }

  /**
   * Convertir resultado del nuevo clasificador a formato legacy
   */
  private convertToLegacyFormat(
    completedSOAP: CompletedSOAP, 
    originalSegments: TranscriptionSegment[]
  ): Omit<SmartSOAPResult, 'processingMetrics'> {
    
    // Convertir segmentos SOAP a formato legacy
    const convertSegments = (soapSegments: SOAPSegment[]): SOAPSection[] => {
      return soapSegments.map(segment => ({
        section: segment.classification.section,
        content: this.generateStructuredContent(
          segment.text,
          segment.classification.section,
          this.convertEntities(segment.classification.entities),
          segment.speaker
        ),
        confidence: segment.classification.confidence,
        originalText: segment.text,
        entities: this.convertEntities(segment.classification.entities),
        speaker: segment.speaker,
        timestamp: segment.timestamp,
        processed: true
      }));
    };

    // Crear sección de Assessment
    const assessmentSection: SOAPSection[] = [{
      section: 'A' as const,
      content: completedSOAP.assessment,
      confidence: 0.9,
      originalText: completedSOAP.assessment,
      entities: [],
      speaker: 'THERAPIST',
      timestamp: Date.now(),
      processed: true
    }];

    return {
      subjective: convertSegments(completedSOAP.subjective),
      objective: convertSegments(completedSOAP.objective),
      assessment: assessmentSection,
      plan: convertSegments(completedSOAP.plan),
      summary: {
        totalSegments: completedSOAP.summary.totalSegments,
        processedSegments: completedSOAP.summary.totalSegments,
        confidence: completedSOAP.summary.confidence,
        keyFindings: completedSOAP.summary.keyFindings,
        recommendations: this.generateRecommendations(completedSOAP),
        autoGeneratedAssessment: completedSOAP.summary.autoGeneratedAssessment
      },
      rawTranscription: originalSegments
    };
  }

  /**
   * Convertir entidades del nuevo formato al legacy
   */
  private convertEntities(medicalEntities: MedicalEntities): MedicalEntity[] {
    const entities: MedicalEntity[] = [];
    
    // Convertir anatomía
    medicalEntities.anatomia.forEach(anatomy => {
      entities.push({
        text: anatomy,
        type: 'ANATOMY',
        confidence: 0.9,
        start: 0,
        end: anatomy.length,
        context: 'Anatomía detectada'
      });
    });
    
    // Convertir síntomas
    medicalEntities.sintomas.forEach(symptom => {
      entities.push({
        text: symptom,
        type: 'SYMPTOM',
        confidence: 0.9,
        start: 0,
        end: symptom.length,
        context: 'Síntoma detectado'
      });
    });
    
    // Convertir procedimientos
    medicalEntities.procedimientos.forEach(procedure => {
      entities.push({
        text: procedure,
        type: 'PROCEDURE',
        confidence: 0.9,
        start: 0,
        end: procedure.length,
        context: 'Procedimiento detectado'
      });
    });
    
    // Convertir medicamentos
    medicalEntities.medicamentos.forEach(medication => {
      entities.push({
        text: medication,
        type: 'MEDICATION',
        confidence: 0.9,
        start: 0,
        end: medication.length,
        context: 'Medicamento detectado'
      });
    });
    
    return entities;
  }

  /**
   * Generar recomendaciones basadas en el resultado
   */
  private generateRecommendations(completedSOAP: CompletedSOAP): string[] {
    const recommendations: string[] = [];
    
    // Recomendaciones basadas en confianza
    if (completedSOAP.summary.confidence < 0.7) {
      recommendations.push('Revisar clasificación manual - confianza baja');
    }
    
    // Recomendaciones basadas en contenido
    if (completedSOAP.subjective.length === 0) {
      recommendations.push('Considerar agregar más información subjetiva del paciente');
    }
    
    if (completedSOAP.objective.length === 0) {
      recommendations.push('Incluir más observaciones del examen físico');
    }
    
    if (completedSOAP.plan.length === 0) {
      recommendations.push('Definir plan de tratamiento específico');
    }
    
    // Recomendaciones basadas en entidades
    const allEntities = this.getAllEntities(completedSOAP);
    if (allEntities.anatomia.length === 0) {
      recommendations.push('Especificar áreas anatómicas afectadas');
    }
    
    if (allEntities.sintomas.length === 0) {
      recommendations.push('Documentar síntomas específicos del paciente');
    }
    
    return recommendations;
  }

  /**
   * Obtener todas las entidades del resultado
   */
  private getAllEntities(completedSOAP: CompletedSOAP): MedicalEntities {
    const allSegments = [
      ...completedSOAP.subjective,
      ...completedSOAP.objective,
      ...completedSOAP.plan
    ];
    
    const combined: MedicalEntities = {
      anatomia: [],
      sintomas: [],
      procedimientos: [],
      medicamentos: []
    };
    
    allSegments.forEach(segment => {
      combined.anatomia.push(...segment.classification.entities.anatomia);
      combined.sintomas.push(...segment.classification.entities.sintomas);
      combined.procedimientos.push(...segment.classification.entities.procedimientos);
      combined.medicamentos.push(...segment.classification.entities.medicamentos);
    });
    
    // Eliminar duplicados
    combined.anatomia = [...new Set(combined.anatomia)];
    combined.sintomas = [...new Set(combined.sintomas)];
    combined.procedimientos = [...new Set(combined.procedimientos)];
    combined.medicamentos = [...new Set(combined.medicamentos)];
    
    return combined;
  }

  /**
   * Contar total de entidades
   */
  private countTotalEntities(completedSOAP: CompletedSOAP): number {
    const allEntities = this.getAllEntities(completedSOAP);
    return allEntities.anatomia.length + 
           allEntities.sintomas.length + 
           allEntities.procedimientos.length + 
           allEntities.medicamentos.length;
  }

  // === MÉTODOS LEGACY MANTENIDOS PARA COMPATIBILIDAD ===

  /**
   * Generar contenido estructurado (legacy)
   */
  private generateStructuredContent(
    originalText: string,
    section: 'S' | 'O' | 'A' | 'P',
    entities: MedicalEntity[],
    speaker: string
  ): string {
    
    // Si no hay entidades, devolver texto original
    if (entities.length === 0) {
      return originalText;
    }

    // Generar contenido estructurado basado en entidades
    let structuredContent = originalText;
    
    // Agregar contexto médico según la sección
    switch (section) {
      case 'S':
        if (entities.some(e => e.type === 'SYMPTOM')) {
          const symptoms = entities.filter(e => e.type === 'SYMPTOM').map(e => e.text);
          structuredContent += ` [Síntomas identificados: ${symptoms.join(', ')}]`;
        }
        break;
        
      case 'O':
        if (entities.some(e => e.type === 'ANATOMY')) {
          const anatomy = entities.filter(e => e.type === 'ANATOMY').map(e => e.text);
          structuredContent += ` [Áreas evaluadas: ${anatomy.join(', ')}]`;
        }
        break;
        
      case 'P':
        if (entities.some(e => e.type === 'PROCEDURE')) {
          const procedures = entities.filter(e => e.type === 'PROCEDURE').map(e => e.text);
          structuredContent += ` [Procedimientos: ${procedures.join(', ')}]`;
        }
        break;
    }
    
    return structuredContent;
  }

  /**
   * Obtener estadísticas de procesamiento
   */
  getProcessingStats() {
    return {
      ...this.processingStats,
      classifierVersion: 'AdvancedSOAPClassifier V3.0',
      geminiAvailable: this.geminiAvailable
    };
  }

  /**
   * Reiniciar estadísticas
   */
  resetStats() {
    this.processingStats = {
      totalProcessed: 0,
      aiClassified: 0,
      fallbackClassified: 0,
      entitiesExtracted: 0
    };
  }

  /**
   * MÉTODO DIRECTO: Usar el clasificador avanzado directamente
   */
  public classifySegmentDirect(text: string, speaker: 'PATIENT' | 'THERAPIST' | 'UNKNOWN'): ClassificationResult {
    return this.classifier.classifySOAPSegment(text, speaker);
  }

  /**
   * MÉTODO DIRECTO: Extraer entidades médicas
   */
  public extractEntitiesDirect(text: string): MedicalEntities {
    return this.classifier.extractMedicalEntities(text);
  }

  /**
   * MÉTODO DIRECTO: Inferir hablante
   */
  public guessSpeakerDirect(text: string): 'PATIENT' | 'THERAPIST' {
    return this.classifier.guessSpeaker(text);
  }
}

export default SmartSOAPProcessor; 