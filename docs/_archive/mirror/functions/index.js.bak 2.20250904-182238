const functions = require('firebase-functions');
const { GoogleAuth } = require('google-auth-library');
const auth = new GoogleAuth({
  scopes: ['https://www.googleapis.com/auth/cloud-platform']
});

exports.processWithVertexAI = functions.https.onCall(async (data, context) => {
  const { prompt } = data;
  
  if (!prompt) {
    throw new functions.https.HttpsError('invalid-argument', 'Prompt requerido');
  }
  
  try {
    const client = await auth.getClient();
    const token = await client.getAccessToken();
    
    const response = await fetch(
      'https://us-central1-aiplatform.googleapis.com/v1/projects/aiduxcare-v2-uat-dev/locations/us-central1/publishers/google/models/gemini-2.5-flash:generateContent',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token.token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            role: 'user',
            parts: [{ text: prompt }]
          }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 4096,
            topP: 0.8
          }
        })
      }
    );
    
    const result = await response.json();
    return {
      text: result.candidates?.[0]?.content?.parts?.[0]?.text || '',
      usage: result.usageMetadata
    };
  } catch (error) {
    console.error('Error:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});

exports.vertexAIProxy = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }
  
  try {
    const { text, prompt } = req.body;
    
    // PROMPT ESPECIALIZADO PARA FISIOTERAPIA/MSK CON RED FLAGS
    const fullPrompt = prompt || `Analiza esta consulta de fisioterapia:

${text}

Identifica:
1. Banderas rojas (emergencias m√©dicas nuevas, no condiciones conocidas en tratamiento)
2. Banderas amarillas (factores psicosociales)
3. S√≠ntomas principales
4. Condiciones m√©dicas
5. Medicamentos
6. evaluaciones_fisicas_sugeridas

Responde en formato JSON estructurado.`;
    const client = await auth.getClient();
    const token = await client.getAccessToken();    
    const response = await fetch(
      'https://us-central1-aiplatform.googleapis.com/v1/projects/aiduxcare-v2-uat-dev/locations/us-central1/publishers/google/models/gemini-2.0-flash-exp:generateContent',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token.token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            role: 'user',
            parts: [{ text: fullPrompt }]
          }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 4096,
            topP: 0.8
          }
        })
      }
    );
    
    const result = await response.json();
    const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text || '';
    console.log("Respuesta de Vertex (primeros 500 chars):", responseText.substring(0, 500));
    console.log("Longitud total de respuesta:", responseText.length);    
    const startTime = Date.now();
    
    // Intentar parsear como JSON primero
    try {
      // Limpiar el texto por si viene con markdown
      let cleanJson = responseText;
      if (responseText.includes('```json')) {
        cleanJson = responseText.split('```json')[1].split('```')[0];
      } else if (responseText.includes('```')) {
        cleanJson = responseText.split('```')[1].split('```')[0];
      }
      
      const jsonResponse = JSON.parse(cleanJson);
      console.log("‚úÖ Respuesta parseada como JSON");
      console.log("Campos en JSON parseado:", Object.keys(jsonResponse));      
      // Construir respuesta compatible con el frontend
      let entities = [];
      let redFlags = [];
      let yellowFlags = [];
      let physicalTests = [];      let idCounter = 1;
      
      // Procesar banderas rojas
      if (jsonResponse.banderas_rojas && Array.isArray(jsonResponse.banderas_rojas) && jsonResponse.banderas_rojas.length > 0) {
        jsonResponse.banderas_rojas.forEach(br => {
          redFlags.push({
            pattern: br.tipo || br.descripcion,
            action: br.accion || "Evaluar derivaci√≥n",
            urgency: br.urgencia === "inmediata" ? "urgent" : "high",
            description: br.descripcion
          });
          
          entities.push({
            id: String(idCounter++),
            text: `üö® RED FLAG: ${br.tipo || br.descripcion}`,
            type: 'condition',
            clinicalRelevance: 'critical'
          });
        });
      }
      
      // Procesar banderas amarillas
      if (jsonResponse.banderas_amarillas && Array.isArray(jsonResponse.banderas_amarillas)) {
        yellowFlags = jsonResponse.banderas_amarillas;
        jsonResponse.banderas_amarillas.forEach(ba => {
          entities.push({
            id: String(idCounter++),
            text: `‚ö° ${ba}`,
            type: 'other',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar s√≠ntomas
      if (jsonResponse.sintomas_principales) {
        jsonResponse.sintomas_principales.forEach(sintoma => {
          entities.push({
            id: String(idCounter++),
            text: `‚ö†Ô∏è ${sintoma}`,
            type: 'symptom',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar condiciones m√©dicas
      if (jsonResponse.condiciones_medicas) {
        jsonResponse.condiciones_medicas.forEach(condicion => {
          entities.push({
            id: String(idCounter++),
            text: `üè• ${condicion}`,
            type: 'condition',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar medicamentos
      if (jsonResponse.medicamentos) {
        jsonResponse.medicamentos.forEach(med => {
          const medText = typeof med === 'string' ? med : `${med.nombre} ${med.dosis || ''}`.trim();
          entities.push({
            id: String(idCounter++),
            text: `üíä ${medText}`,
            type: 'medication',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar evaluaciones sugeridas
      if (jsonResponse.evaluaciones_sugeridas) {
      // Procesar evaluaciones_fisicas_sugeridas (nuevo formato)
      if (jsonResponse.evaluaciones_fisicas_sugeridas) {
        jsonResponse.evaluaciones_fisicas_sugeridas.forEach(test => {
          physicalTests.push(test);
        });
      }        jsonResponse.evaluaciones_sugeridas.forEach(eval => {
          if (eval.tests) {
            eval.tests.forEach(test => {
              entities.push({
                id: String(idCounter++),
                text: `üìã ${test}`,
                type: 'other',
                clinicalRelevance: 'medium'
              });
            });
          }
        });
      }
      
      // Generar resumen
      let summary = jsonResponse.contexto_clinico || jsonResponse.motivo_consulta || "";
      if (redFlags.length > 0) {
        summary = `‚ö†Ô∏è ALERTA: ${redFlags.length} RED FLAG(S) DETECTADO(S). ${summary}`;
      }
      
      res.json({
        entities: entities,
        redFlags: redFlags,
        yellowFlags: yellowFlags,
        otherFlags: { orange: [], blue: [], black: [] },
        physicalTests: physicalTests,
        standardizedMeasures: [],
        rawResponse: responseText,
        summary: summary,
        requiresSelection: true,
        metadata: {
          processingTime: (Date.now() - startTime) / 1000,
          estimatedTimeSaved: 15,
          timestamp: new Date().toISOString(),
          specialty: 'physiotherapy_msk'
        }
      });
      return;
      
    } catch (jsonError) {
      console.error("Error parseando JSON:", jsonError.message);
      console.log("JSON que fall√≥ (√∫ltimos 200 chars):", responseText.slice(-200));      console.log("No es JSON, usando parsing de texto como fallback");
    }
    
    // FALLBACK: Parsing de texto existente
    try {
      // Limpiar el texto por si viene con markdown
      let cleanJson = responseText;
      if (responseText.includes('```json')) {
        cleanJson = responseText.split('```json')[1].split('```')[0];
      } else if (responseText.includes('```')) {
        cleanJson = responseText.split('```')[1].split('```')[0];
      }
      
      const jsonResponse = JSON.parse(cleanJson);
      console.log("‚úÖ Respuesta parseada como JSON");
      console.log("Campos en JSON parseado:", Object.keys(jsonResponse));      
      // Construir respuesta compatible con el frontend
      let entities = [];
      let redFlags = [];
      let yellowFlags = [];
      let physicalTests = [];      let idCounter = 1;
      
      // Procesar banderas rojas
      if (jsonResponse.banderas_rojas && Array.isArray(jsonResponse.banderas_rojas) && jsonResponse.banderas_rojas.length > 0) {
        jsonResponse.banderas_rojas.forEach(br => {
          redFlags.push({
            pattern: br.tipo || br.descripcion,
            action: br.accion || "Evaluar derivaci√≥n",
            urgency: br.urgencia === "inmediata" ? "urgent" : "high",
            description: br.descripcion
          });
          
          entities.push({
            id: String(idCounter++),
            text: `üö® RED FLAG: ${br.tipo || br.descripcion}`,
            type: 'condition',
            clinicalRelevance: 'critical'
          });
        });
      }
      
      // Procesar banderas amarillas
      if (jsonResponse.banderas_amarillas && Array.isArray(jsonResponse.banderas_amarillas)) {
        yellowFlags = jsonResponse.banderas_amarillas;
        jsonResponse.banderas_amarillas.forEach(ba => {
          entities.push({
            id: String(idCounter++),
            text: `‚ö° ${ba}`,
            type: 'other',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar s√≠ntomas
      if (jsonResponse.sintomas_principales) {
        jsonResponse.sintomas_principales.forEach(sintoma => {
          entities.push({
            id: String(idCounter++),
            text: `‚ö†Ô∏è ${sintoma}`,
            type: 'symptom',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar condiciones m√©dicas
      if (jsonResponse.condiciones_medicas) {
        jsonResponse.condiciones_medicas.forEach(condicion => {
          entities.push({
            id: String(idCounter++),
            text: `üè• ${condicion}`,
            type: 'condition',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar medicamentos
      if (jsonResponse.medicamentos) {
        jsonResponse.medicamentos.forEach(med => {
          const medText = typeof med === 'string' ? med : `${med.nombre} ${med.dosis || ''}`.trim();
          entities.push({
            id: String(idCounter++),
            text: `üíä ${medText}`,
            type: 'medication',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar evaluaciones sugeridas
      if (jsonResponse.evaluaciones_sugeridas) {
      // Procesar evaluaciones_fisicas_sugeridas (nuevo formato)
      if (jsonResponse.evaluaciones_fisicas_sugeridas) {
        jsonResponse.evaluaciones_fisicas_sugeridas.forEach(test => {
          physicalTests.push(test);
        });
      }        jsonResponse.evaluaciones_sugeridas.forEach(eval => {
          if (eval.tests) {
            eval.tests.forEach(test => {
              entities.push({
                id: String(idCounter++),
                text: `üìã ${test}`,
                type: 'other',
                clinicalRelevance: 'medium'
              });
            });
          }
        });
      }
      
      // Generar resumen
      let summary = jsonResponse.contexto_clinico || jsonResponse.motivo_consulta || "";
      if (redFlags.length > 0) {
        summary = `‚ö†Ô∏è ALERTA: ${redFlags.length} RED FLAG(S) DETECTADO(S). ${summary}`;
      }
      
      res.json({
        entities: entities,
        redFlags: redFlags,
        yellowFlags: yellowFlags,
        otherFlags: { orange: [], blue: [], black: [] },
        physicalTests: physicalTests,
        standardizedMeasures: [],
        rawResponse: responseText,
        summary: summary,
        requiresSelection: true,
        metadata: {
          processingTime: (Date.now() - startTime) / 1000,
          estimatedTimeSaved: 15,
          timestamp: new Date().toISOString(),
          specialty: 'physiotherapy_msk'
        }
      });
      return;
      
    } catch (jsonError) {
      console.error("Error parseando JSON:", jsonError.message);
      console.log("JSON que fall√≥ (√∫ltimos 200 chars):", responseText.slice(-200));      console.log("No es JSON, usando parsing de texto como fallback");
    }
    
    // FALLBACK: Parsing de texto existente
    try {
      // Limpiar el texto por si viene con markdown
      let cleanJson = responseText;
      if (responseText.includes('```json')) {
        cleanJson = responseText.split('```json')[1].split('```')[0];
      } else if (responseText.includes('```')) {
        cleanJson = responseText.split('```')[1].split('```')[0];
      }
      
      const jsonResponse = JSON.parse(cleanJson);
      console.log("‚úÖ Respuesta parseada como JSON");
      console.log("Campos en JSON parseado:", Object.keys(jsonResponse));      
      // Construir respuesta compatible con el frontend
      let entities = [];
      let redFlags = [];
      let yellowFlags = [];
      let physicalTests = [];      let idCounter = 1;
      
      // Procesar banderas rojas
      if (jsonResponse.banderas_rojas && Array.isArray(jsonResponse.banderas_rojas) && jsonResponse.banderas_rojas.length > 0) {
        jsonResponse.banderas_rojas.forEach(br => {
          redFlags.push({
            pattern: br.tipo || br.descripcion,
            action: br.accion || "Evaluar derivaci√≥n",
            urgency: br.urgencia === "inmediata" ? "urgent" : "high",
            description: br.descripcion
          });
          
          entities.push({
            id: String(idCounter++),
            text: `üö® RED FLAG: ${br.tipo || br.descripcion}`,
            type: 'condition',
            clinicalRelevance: 'critical'
          });
        });
      }
      
      // Procesar banderas amarillas
      if (jsonResponse.banderas_amarillas && Array.isArray(jsonResponse.banderas_amarillas)) {
        yellowFlags = jsonResponse.banderas_amarillas;
        jsonResponse.banderas_amarillas.forEach(ba => {
          entities.push({
            id: String(idCounter++),
            text: `‚ö° ${ba}`,
            type: 'other',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar s√≠ntomas
      if (jsonResponse.sintomas_principales) {
        jsonResponse.sintomas_principales.forEach(sintoma => {
          entities.push({
            id: String(idCounter++),
            text: `‚ö†Ô∏è ${sintoma}`,
            type: 'symptom',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar condiciones m√©dicas
      if (jsonResponse.condiciones_medicas) {
        jsonResponse.condiciones_medicas.forEach(condicion => {
          entities.push({
            id: String(idCounter++),
            text: `üè• ${condicion}`,
            type: 'condition',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar medicamentos
      if (jsonResponse.medicamentos) {
        jsonResponse.medicamentos.forEach(med => {
          const medText = typeof med === 'string' ? med : `${med.nombre} ${med.dosis || ''}`.trim();
          entities.push({
            id: String(idCounter++),
            text: `üíä ${medText}`,
            type: 'medication',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar evaluaciones sugeridas
      if (jsonResponse.evaluaciones_sugeridas) {
      // Procesar evaluaciones_fisicas_sugeridas (nuevo formato)
      if (jsonResponse.evaluaciones_fisicas_sugeridas) {
        jsonResponse.evaluaciones_fisicas_sugeridas.forEach(test => {
          physicalTests.push(test);
        });
      }        jsonResponse.evaluaciones_sugeridas.forEach(eval => {
          if (eval.tests) {
            eval.tests.forEach(test => {
              entities.push({
                id: String(idCounter++),
                text: `üìã ${test}`,
                type: 'other',
                clinicalRelevance: 'medium'
              });
            });
          }
        });
      }
      
      // Generar resumen
      let summary = jsonResponse.contexto_clinico || jsonResponse.motivo_consulta || "";
      if (redFlags.length > 0) {
        summary = `‚ö†Ô∏è ALERTA: ${redFlags.length} RED FLAG(S) DETECTADO(S). ${summary}`;
      }
      
      res.json({
        entities: entities,
        redFlags: redFlags,
        yellowFlags: yellowFlags,
        otherFlags: { orange: [], blue: [], black: [] },
        physicalTests: physicalTests,
        standardizedMeasures: [],
        rawResponse: responseText,
        summary: summary,
        requiresSelection: true,
        metadata: {
          processingTime: (Date.now() - startTime) / 1000,
          estimatedTimeSaved: 15,
          timestamp: new Date().toISOString(),
          specialty: 'physiotherapy_msk'
        }
      });
      return;
      
    } catch (jsonError) {
      console.error("Error parseando JSON:", jsonError.message);
      console.log("JSON que fall√≥ (√∫ltimos 200 chars):", responseText.slice(-200));      console.log("No es JSON, usando parsing de texto como fallback");
    }
    
    // FALLBACK: Parsing de texto existente
    let idCounter = 1;
    
    // Tracking de tiempo ahorrado (m√©trica para el dashboard)
    
    // Dividir el texto en secciones
    const sections = {
      redflags: [],
      yellowflags: [],
      conditions: [],
      symptoms: [],
      medications: [],
      tests: [],
      plan: []
    };
    
    let currentSection = null;
    const lines = responseText.split('\n');
    
    lines.forEach(line => {
      // Detectar secci√≥n actual
      if (line.includes('**Red Flags')) {
        currentSection = 'redflags';
        return;
      } else if (line.includes('**Banderas Amarillas')) {
        currentSection = 'yellowflags';
        return;
      } else if (line.includes('**Condiciones') || line.includes('**Diagn√≥stico')) {
        currentSection = 'conditions';
        return;
      } else if (line.includes('**S√≠ntomas:**')) {
        currentSection = 'symptoms';
        return;
      } else if (line.includes('**Medicamentos:**')) {
        currentSection = 'medications';
        return;
      } else if (line.includes('**Tests') || line.includes('**Evaluac')) {
        currentSection = 'tests';
        return;
      } else if (line.includes('**Plan')) {
        currentSection = 'plan';
        return;
      }
      
      // Extraer RED FLAGS
      if (currentSection === 'redflags' && line.includes('URGENCIA:')) {
        const urgencyMatch = line.match(/URGENCIA:\s*(EMERGENCY|URGENT|MODERATE)/i);
        const typeMatch = line.match(/\*\*\[?([^\]]+)\]?\*\*/);
        
        if (urgencyMatch && typeMatch) {
          const urgencyLevel = urgencyMatch[1].toUpperCase();
          const flagType = typeMatch[1].replace(/[\[\]]/g, '').trim();
          const description = line.split(':').slice(1).join(':').split('-')[0].trim();
          
          redFlags.push({
            pattern: flagType,
            action: urgencyLevel === 'EMERGENCY' ? 
              'üö® DERIVAR A URGENCIAS INMEDIATAMENTE - Documentar hora y m√©todo de derivaci√≥n' : 
              urgencyLevel === 'URGENT' ? 
              '‚ö†Ô∏è Derivar a m√©dico en <24-48h - Documentar comunicaci√≥n con paciente' : 
              '‚ö° Evaluar y considerar derivaci√≥n seg√∫n evoluci√≥n',
            urgency: urgencyLevel === 'EMERGENCY' ? 'urgent' : 
                     urgencyLevel === 'URGENT' ? 'high' : 'medium',
            description: description,
            reference: 'CPG MSK 2024'
          });
          
          // A√±adir tambi√©n como entidad cr√≠tica para visualizaci√≥n
          entities.push({
            id: String(idCounter++),
            text: `üö® RED FLAG: ${flagType}`,
            type: 'condition',
            clinicalRelevance: 'critical'
          });
        }
      }
      
      // Extraer BANDERAS AMARILLAS
      if (currentSection === 'yellowflags' && line.includes('**') && line.includes('*')) {
        const match = line.match(/\*\*([^*:]+)/);
        if (match && match[1] && !match[1].includes('No se detectaron')) {
          const yellowFlag = match[1].trim();
          yellowFlags.push(yellowFlag);
          
          // A√±adir como entidad para tracking
          entities.push({
            id: String(idCounter++),
            text: `‚ö° Bandera Amarilla: ${yellowFlag}`,
            type: 'other',
            clinicalRelevance: 'medium'
          });
        }
      }
      
      // Extraer entidades normales de las otras secciones
      if (currentSection && !['redflags', 'yellowflags'].includes(currentSection) && 
          line.includes('**') && line.includes('*')) {
        const match = line.match(/\*\*([^*:]+)/);
        if (match && match[1]) {
          const text = match[1].trim();
          if (text.length > 2 && !text.includes('No se detectaron')) {
            const types = {
              conditions: { type: 'condition', icon: 'üîç', relevance: 'high' },
              symptoms: { type: 'symptom', icon: '‚ö†Ô∏è', relevance: 'high' },
              medications: { type: 'medication', icon: 'üíä', relevance: 'medium' },
              tests: { type: 'other', icon: 'üìã', relevance: 'high' }, // Cambiado a 'other' por compatibilidad
              plan: { type: 'other', icon: 'üìù', relevance: 'medium' }
            };
            
            const config = types[currentSection] || { type: 'other', icon: 'üìå', relevance: 'medium' };
            
            entities.push({
              id: String(idCounter++),
              text: config.icon + ' ' + text,
              type: config.type,
              clinicalRelevance: config.relevance
            });
          }
        }
      }
    });

    // Calcular tiempo ahorrado estimado (15-20 min por nota bien documentada)
    const processingTime = (Date.now() - startTime) / 1000; // en segundos
    const estimatedTimeSaved = 15; // minutos promedio ahorrados
    
    // Preparar resumen con alertas prioritarias
    let summary = responseText.substring(0, 200);
    if (redFlags.length > 0) {
      summary = `‚ö†Ô∏è ALERTA: ${redFlags.length} RED FLAG(S) DETECTADO(S) - Requiere acci√≥n inmediata. ` + summary;
    } else if (yellowFlags.length > 0) {
      summary = `‚ö° ${yellowFlags.length} bandera(s) amarilla(s) detectada(s) - Factores psicosociales presentes. ` + summary;
    }

    // Respuesta estructurada compatible con tipos existentes
    res.json({
      entities: entities,
      redFlags: redFlags,
      yellowFlags: yellowFlags,
      otherFlags: {
        orange: [], // Factores psiqui√°tricos (para futuro)
        blue: [],   // Factores laborales (para futuro)
        black: []   // Factores del sistema (para futuro)
      },
      physicalTests: entities.filter(e => e.text.includes('üìã')).map(e => ({
        name: e.text.replace('üìã ', ''),
        rationale: 'Evaluaci√≥n cl√≠nica indicada',
        sensitivity: null,
        specificity: null
      })),
      standardizedMeasures: [], // NPRS, Oswestry, etc (para futuro)
      summary: summary,
      rawResponse: responseText,
      modelUsed: 'flash',
      requiresSelection: true,
      metadata: {
        processingTime: processingTime,
        estimatedTimeSaved: estimatedTimeSaved,
        timestamp: new Date().toISOString(),
        specialty: 'physiotherapy_msk'
      }
    });
    
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ error: error.message });
  }
});
// === HOTFIX vertexAIProxy (passthrough robusto, sin 'entities') ===
const functions = require('firebase-functions');
const { GoogleAuth } = require('google-auth-library');

const _auth_for_proxy = new GoogleAuth({ scopes: ['https://www.googleapis.com/auth/cloud-platform'] });

exports.vertexAIProxy = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  if (req.method === 'OPTIONS') return res.status(204).send('');
  if (req.method !== 'POST') return res.status(405).json({ ok:false, error:'method_not_allowed' });

  try {
    const { action='analyze', prompt, transcript, text, traceId } = req.body || {};
    if (action !== 'analyze') return res.status(400).json({ ok:false, error:'unsupported_action', action });

    const inputText =
      (typeof prompt === 'string' && prompt.trim()) ||
      (typeof transcript === 'string' && transcript.trim()) ||
      (typeof text === 'string' && text.trim()) || null;

    if (!inputText) {
      return res.status(400).json({ ok:false, error:'missing_input', message:"Provide 'prompt' or 'transcript' or 'text'." });
    }

    const client = await _auth_for_proxy.getClient();
    const tokenObj = await client.getAccessToken();
    const accessToken = (tokenObj && (tokenObj.token || tokenObj)) ? (tokenObj.token || tokenObj) : null;
    if (!accessToken) throw new Error('Failed to acquire access token');

    const endpoint = 'https://us-central1-aiplatform.googleapis.com/v1/projects/aiduxcare-v2-uat-dev/locations/us-central1/publishers/google/models/gemini-2.5-flash:generateContent';

    const payload = {
      contents: [{ role: 'user', parts: [{ text: inputText }] }],
      generationConfig: {
        temperature: 0.3,
        maxOutputTokens: 4096,
        response_mime_type: 'application/json'
      }
    };

    const r = await fetch(endpoint, {
      method: 'POST',
      headers: { Authorization: `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    const data = await r.json();

    return res.status(200).json({
      ok: true,
      project: 'aiduxcare-v2-uat-dev',
      location: 'us-central1',
      model: 'gemini-2.5-flash',
      traceId: traceId || null,
      text: data?.candidates?.[0]?.content?.parts?.[0]?.text || '',
      vertexRaw: data
    });
  } catch (err) {
    console.error('vertexAIProxy error:', err?.stack || err);
    return res.status(500).json({ ok:false, error:'vertex_invoke_failed', message: err?.message || 'Unknown error' });
  }
});
