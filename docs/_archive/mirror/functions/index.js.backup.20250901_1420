const functions = require('firebase-functions');
const { GoogleAuth } = require('google-auth-library');
const auth = new GoogleAuth({
  scopes: ['https://www.googleapis.com/auth/cloud-platform']
});

exports.processWithVertexAI = functions.https.onCall(async (data, context) => {
  const { prompt } = data;
  
  if (!prompt) {
    throw new functions.https.HttpsError('invalid-argument', 'Prompt requerido');
  }
  
  try {
    const client = await auth.getClient();
    const token = await client.getAccessToken();
    
    const response = await fetch(
      'https://us-central1-aiplatform.googleapis.com/v1/projects/aiduxcare-v2-uat-dev/locations/us-central1/publishers/google/models/gemini-2.5-flash:generateContent',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token.token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            role: 'user',
            parts: [{ text: prompt }]
          }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 2048,
            topP: 0.8
          }
        })
      }
    );
    
    const result = await response.json();
    return {
      text: result.candidates?.[0]?.content?.parts?.[0]?.text || '',
      usage: result.usageMetadata
    };
  } catch (error) {
    console.error('Error:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});

exports.vertexAIProxy = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }
  
  try {
    const { text, prompt } = req.body;
    
    // PROMPT ESPECIALIZADO PARA FISIOTERAPIA/MSK CON RED FLAGS
    // Usar prompt inteligente de análisis de anamnesis
    const fullPrompt = `Analiza esta consulta inicial de fisioterapia y organiza la información para la evaluación:

${text}

Consideraciones importantes:
- El paciente ya está en consulta de fisioterapia
- Condiciones médicas conocidas bajo tratamiento NO son emergencias
- Solo marca red flags si hay signos/síntomas NUEVOS y AGUDOS

Devuelve un JSON con: banderas_rojas, banderas_amarillas, sintomas_principales, condiciones_medicas, medicamentos, evaluaciones_sugeridas, precauciones, contexto_clinico, motivo_consulta`;* **Ejercicio terapéutico:** tipo y progresión
* **Modalidades:** si aplica
* **Educación del paciente:** puntos clave`;
    
    const client = await auth.getClient();
    const token = await client.getAccessToken();
    
    const response = await fetch(
      'https://us-central1-aiplatform.googleapis.com/v1/projects/aiduxcare-v2-uat-dev/locations/us-central1/publishers/google/models/gemini-2.0-flash-exp:generateContent',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token.token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            role: 'user',
            parts: [{ text: fullPrompt }]
          }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 2048,
            topP: 0.8
          }
        })
      }
    );
    
    const result = await response.json();
    const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text || '';
    console.log("Respuesta de Vertex (primeros 500 chars):", responseText.substring(0, 500));
    
    const startTime = Date.now();
    
    // Intentar parsear como JSON primero
    try {
      // Limpiar el texto por si viene con markdown
      let cleanJson = responseText;
      if (responseText.includes('```json')) {
        cleanJson = responseText.split('```json')[1].split('```')[0];
      } else if (responseText.includes('```')) {
        cleanJson = responseText.split('```')[1].split('```')[0];
      }
      
      const jsonResponse = JSON.parse(cleanJson);
      console.log("✅ Respuesta parseada como JSON");
      
      // Construir respuesta compatible con el frontend
      let entities = [];
      let redFlags = [];
      let yellowFlags = [];
      let idCounter = 1;
      
      // Procesar banderas rojas
      if (jsonResponse.banderas_rojas && Array.isArray(jsonResponse.banderas_rojas) && jsonResponse.banderas_rojas.length > 0) {
        jsonResponse.banderas_rojas.forEach(br => {
          redFlags.push({
            pattern: br.tipo || br.descripcion,
            action: br.accion || "Evaluar derivación",
            urgency: br.urgencia === "inmediata" ? "urgent" : "high",
            description: br.descripcion
          });
          
          entities.push({
            id: String(idCounter++),
            text: `🚨 RED FLAG: ${br.tipo || br.descripcion}`,
            type: 'condition',
            clinicalRelevance: 'critical'
          });
        });
      }
      
      // Procesar banderas amarillas
      if (jsonResponse.banderas_amarillas && Array.isArray(jsonResponse.banderas_amarillas)) {
        yellowFlags = jsonResponse.banderas_amarillas;
        jsonResponse.banderas_amarillas.forEach(ba => {
          entities.push({
            id: String(idCounter++),
            text: `⚡ ${ba}`,
            type: 'other',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar síntomas
      if (jsonResponse.sintomas_principales) {
        jsonResponse.sintomas_principales.forEach(sintoma => {
          entities.push({
            id: String(idCounter++),
            text: `⚠️ ${sintoma}`,
            type: 'symptom',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar condiciones médicas
      if (jsonResponse.condiciones_medicas) {
        jsonResponse.condiciones_medicas.forEach(condicion => {
          entities.push({
            id: String(idCounter++),
            text: `🏥 ${condicion}`,
            type: 'condition',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar medicamentos
      if (jsonResponse.medicamentos) {
        jsonResponse.medicamentos.forEach(med => {
          const medText = typeof med === 'string' ? med : `${med.nombre} ${med.dosis || ''}`.trim();
          entities.push({
            id: String(idCounter++),
            text: `💊 ${medText}`,
            type: 'medication',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar evaluaciones sugeridas
      if (jsonResponse.evaluaciones_sugeridas) {
        jsonResponse.evaluaciones_sugeridas.forEach(eval => {
          if (eval.tests) {
            eval.tests.forEach(test => {
              entities.push({
                id: String(idCounter++),
                text: `📋 ${test}`,
                type: 'other',
                clinicalRelevance: 'medium'
              });
            });
          }
        });
      }
      
      // Generar resumen
      let summary = jsonResponse.contexto_clinico || jsonResponse.motivo_consulta || "";
      if (redFlags.length > 0) {
        summary = `⚠️ ALERTA: ${redFlags.length} RED FLAG(S) DETECTADO(S). ${summary}`;
      }
      
      res.json({
        entities: entities,
        redFlags: redFlags,
        yellowFlags: yellowFlags,
        otherFlags: { orange: [], blue: [], black: [] },
        physicalTests: [],
        standardizedMeasures: [],
        rawResponse: responseText,
        summary: summary,
        requiresSelection: true,
        metadata: {
          processingTime: (Date.now() - startTime) / 1000,
          estimatedTimeSaved: 15,
          timestamp: new Date().toISOString(),
          specialty: 'physiotherapy_msk'
        }
      });
      return;
      
    } catch (jsonError) {
      console.log("No es JSON, usando parsing de texto como fallback");
    }
    
    // FALLBACK: Parsing de texto existente
    try {
      // Limpiar el texto por si viene con markdown
      let cleanJson = responseText;
      if (responseText.includes('```json')) {
        cleanJson = responseText.split('```json')[1].split('```')[0];
      } else if (responseText.includes('```')) {
        cleanJson = responseText.split('```')[1].split('```')[0];
      }
      
      const jsonResponse = JSON.parse(cleanJson);
      console.log("✅ Respuesta parseada como JSON");
      
      // Construir respuesta compatible con el frontend
      let entities = [];
      let redFlags = [];
      let yellowFlags = [];
      let idCounter = 1;
      
      // Procesar banderas rojas
      if (jsonResponse.banderas_rojas && Array.isArray(jsonResponse.banderas_rojas) && jsonResponse.banderas_rojas.length > 0) {
        jsonResponse.banderas_rojas.forEach(br => {
          redFlags.push({
            pattern: br.tipo || br.descripcion,
            action: br.accion || "Evaluar derivación",
            urgency: br.urgencia === "inmediata" ? "urgent" : "high",
            description: br.descripcion
          });
          
          entities.push({
            id: String(idCounter++),
            text: `🚨 RED FLAG: ${br.tipo || br.descripcion}`,
            type: 'condition',
            clinicalRelevance: 'critical'
          });
        });
      }
      
      // Procesar banderas amarillas
      if (jsonResponse.banderas_amarillas && Array.isArray(jsonResponse.banderas_amarillas)) {
        yellowFlags = jsonResponse.banderas_amarillas;
        jsonResponse.banderas_amarillas.forEach(ba => {
          entities.push({
            id: String(idCounter++),
            text: `⚡ ${ba}`,
            type: 'other',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar síntomas
      if (jsonResponse.sintomas_principales) {
        jsonResponse.sintomas_principales.forEach(sintoma => {
          entities.push({
            id: String(idCounter++),
            text: `⚠️ ${sintoma}`,
            type: 'symptom',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar condiciones médicas
      if (jsonResponse.condiciones_medicas) {
        jsonResponse.condiciones_medicas.forEach(condicion => {
          entities.push({
            id: String(idCounter++),
            text: `🏥 ${condicion}`,
            type: 'condition',
            clinicalRelevance: 'high'
          });
        });
      }
      
      // Procesar medicamentos
      if (jsonResponse.medicamentos) {
        jsonResponse.medicamentos.forEach(med => {
          const medText = typeof med === 'string' ? med : `${med.nombre} ${med.dosis || ''}`.trim();
          entities.push({
            id: String(idCounter++),
            text: `💊 ${medText}`,
            type: 'medication',
            clinicalRelevance: 'medium'
          });
        });
      }
      
      // Procesar evaluaciones sugeridas
      if (jsonResponse.evaluaciones_sugeridas) {
        jsonResponse.evaluaciones_sugeridas.forEach(eval => {
          if (eval.tests) {
            eval.tests.forEach(test => {
              entities.push({
                id: String(idCounter++),
                text: `📋 ${test}`,
                type: 'other',
                clinicalRelevance: 'medium'
              });
            });
          }
        });
      }
      
      // Generar resumen
      let summary = jsonResponse.contexto_clinico || jsonResponse.motivo_consulta || "";
      if (redFlags.length > 0) {
        summary = `⚠️ ALERTA: ${redFlags.length} RED FLAG(S) DETECTADO(S). ${summary}`;
      }
      
      res.json({
        entities: entities,
        redFlags: redFlags,
        yellowFlags: yellowFlags,
        otherFlags: { orange: [], blue: [], black: [] },
        physicalTests: [],
        standardizedMeasures: [],
        rawResponse: responseText,
        summary: summary,
        requiresSelection: true,
        metadata: {
          processingTime: (Date.now() - startTime) / 1000,
          estimatedTimeSaved: 15,
          timestamp: new Date().toISOString(),
          specialty: 'physiotherapy_msk'
        }
      });
      return;
      
    } catch (jsonError) {
      console.log("No es JSON, usando parsing de texto como fallback");
    }
    
    // FALLBACK: Parsing de texto existente
    let idCounter = 1;
    
    // Tracking de tiempo ahorrado (métrica para el dashboard)
    const startTime = Date.now();
    
    // Dividir el texto en secciones
    const sections = {
      redflags: [],
      yellowflags: [],
      conditions: [],
      symptoms: [],
      medications: [],
      tests: [],
      plan: []
    };
    
    let currentSection = null;
    const lines = responseText.split('\n');
    
    lines.forEach(line => {
      // Detectar sección actual
      if (line.includes('**Red Flags')) {
        currentSection = 'redflags';
        return;
      } else if (line.includes('**Banderas Amarillas')) {
        currentSection = 'yellowflags';
        return;
      } else if (line.includes('**Condiciones') || line.includes('**Diagnóstico')) {
        currentSection = 'conditions';
        return;
      } else if (line.includes('**Síntomas:**')) {
        currentSection = 'symptoms';
        return;
      } else if (line.includes('**Medicamentos:**')) {
        currentSection = 'medications';
        return;
      } else if (line.includes('**Tests') || line.includes('**Evaluac')) {
        currentSection = 'tests';
        return;
      } else if (line.includes('**Plan')) {
        currentSection = 'plan';
        return;
      }
      
      // Extraer RED FLAGS
      if (currentSection === 'redflags' && line.includes('URGENCIA:')) {
        const urgencyMatch = line.match(/URGENCIA:\s*(EMERGENCY|URGENT|MODERATE)/i);
        const typeMatch = line.match(/\*\*\[?([^\]]+)\]?\*\*/);
        
        if (urgencyMatch && typeMatch) {
          const urgencyLevel = urgencyMatch[1].toUpperCase();
          const flagType = typeMatch[1].replace(/[\[\]]/g, '').trim();
          const description = line.split(':').slice(1).join(':').split('-')[0].trim();
          
          redFlags.push({
            pattern: flagType,
            action: urgencyLevel === 'EMERGENCY' ? 
              '🚨 DERIVAR A URGENCIAS INMEDIATAMENTE - Documentar hora y método de derivación' : 
              urgencyLevel === 'URGENT' ? 
              '⚠️ Derivar a médico en <24-48h - Documentar comunicación con paciente' : 
              '⚡ Evaluar y considerar derivación según evolución',
            urgency: urgencyLevel === 'EMERGENCY' ? 'urgent' : 
                     urgencyLevel === 'URGENT' ? 'high' : 'medium',
            description: description,
            reference: 'CPG MSK 2024'
          });
          
          // Añadir también como entidad crítica para visualización
          entities.push({
            id: String(idCounter++),
            text: `🚨 RED FLAG: ${flagType}`,
            type: 'condition',
            clinicalRelevance: 'critical'
          });
        }
      }
      
      // Extraer BANDERAS AMARILLAS
      if (currentSection === 'yellowflags' && line.includes('**') && line.includes('*')) {
        const match = line.match(/\*\*([^*:]+)/);
        if (match && match[1] && !match[1].includes('No se detectaron')) {
          const yellowFlag = match[1].trim();
          yellowFlags.push(yellowFlag);
          
          // Añadir como entidad para tracking
          entities.push({
            id: String(idCounter++),
            text: `⚡ Bandera Amarilla: ${yellowFlag}`,
            type: 'other',
            clinicalRelevance: 'medium'
          });
        }
      }
      
      // Extraer entidades normales de las otras secciones
      if (currentSection && !['redflags', 'yellowflags'].includes(currentSection) && 
          line.includes('**') && line.includes('*')) {
        const match = line.match(/\*\*([^*:]+)/);
        if (match && match[1]) {
          const text = match[1].trim();
          if (text.length > 2 && !text.includes('No se detectaron')) {
            const types = {
              conditions: { type: 'condition', icon: '🔍', relevance: 'high' },
              symptoms: { type: 'symptom', icon: '⚠️', relevance: 'high' },
              medications: { type: 'medication', icon: '💊', relevance: 'medium' },
              tests: { type: 'other', icon: '📋', relevance: 'high' }, // Cambiado a 'other' por compatibilidad
              plan: { type: 'other', icon: '📝', relevance: 'medium' }
            };
            
            const config = types[currentSection] || { type: 'other', icon: '📌', relevance: 'medium' };
            
            entities.push({
              id: String(idCounter++),
              text: config.icon + ' ' + text,
              type: config.type,
              clinicalRelevance: config.relevance
            });
          }
        }
      }
    });

    // Calcular tiempo ahorrado estimado (15-20 min por nota bien documentada)
    const processingTime = (Date.now() - startTime) / 1000; // en segundos
    const estimatedTimeSaved = 15; // minutos promedio ahorrados
    
    // Preparar resumen con alertas prioritarias
    let summary = responseText.substring(0, 200);
    if (redFlags.length > 0) {
      summary = `⚠️ ALERTA: ${redFlags.length} RED FLAG(S) DETECTADO(S) - Requiere acción inmediata. ` + summary;
    } else if (yellowFlags.length > 0) {
      summary = `⚡ ${yellowFlags.length} bandera(s) amarilla(s) detectada(s) - Factores psicosociales presentes. ` + summary;
    }

    // Respuesta estructurada compatible con tipos existentes
    res.json({
      entities: entities,
      redFlags: redFlags,
      yellowFlags: yellowFlags,
      otherFlags: {
        orange: [], // Factores psiquiátricos (para futuro)
        blue: [],   // Factores laborales (para futuro)
        black: []   // Factores del sistema (para futuro)
      },
      physicalTests: entities.filter(e => e.text.includes('📋')).map(e => ({
        name: e.text.replace('📋 ', ''),
        rationale: 'Evaluación clínica indicada',
        sensitivity: null,
        specificity: null
      })),
      standardizedMeasures: [], // NPRS, Oswestry, etc (para futuro)
      summary: summary,
      rawResponse: responseText,
      modelUsed: 'flash',
      requiresSelection: true,
      metadata: {
        processingTime: processingTime,
        estimatedTimeSaved: estimatedTimeSaved,
        timestamp: new Date().toISOString(),
        specialty: 'physiotherapy_msk'
      }
    });
    
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ error: error.message });
  }
});